Hello! I'd be happy to provide a comprehensive code template for a Django REST Framework (DRF) application, complete with a basic project setup, an app, models, serializers, views, URLs, and unit tests.

This template will create a simple API for managing "Products".

---

Here's the code template:

$$$$
&&&& manage.py
@@@@
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()
@@@@
**Explanation:** This is the standard Django `manage.py` file, used for running various administrative tasks like migrations, starting the development server, and running tests. It sets the `DJANGO_SETTINGS_MODULE` to point to your project's settings.

---

$$$$ myproject
&&&& __init__.py
@@@@
@@@@
**Explanation:** An empty `__init__.py` file signifies that `myproject` is a Python package.

---

$$$$ myproject
&&&& settings.py
@@@@
"""
Django settings for myproject project.

Generated by 'django-admin startproject' using Django 5.0.6.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.0/ref/settings/
"""

from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-m&l)2@w9r=s*t!$#d_c#^0_9w-w_b$h81v0097o$6z-x*n0@8y'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Third-party apps
    'rest_framework', # Django REST Framework
    # My apps
    'myapp', # My custom DRF application
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'myproject.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'myproject.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.0/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.0/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.0/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.0/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# Django REST Framework settings (optional, but good to know)
REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.AllowAny', # Allow unauthenticated access by default
        # 'rest_framework.permissions.IsAuthenticated', # Require authentication by default
    ],
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.SessionAuthentication',
        'rest_framework.authentication.BasicAuthentication',
        # 'rest_framework.authentication.TokenAuthentication', # If using Token Auth
    ],
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10,
    'DEFAULT_RENDERER_CLASSES': [
        'rest_framework.renderers.JSONRenderer',
        'rest_framework.renderers.BrowsableAPIRenderer', # For the browsable API
    ],
}
@@@@
**Explanation:**
*   **`INSTALLED_APPS`**: This is crucial. We've added `'rest_framework'` to include the DRF library and `'myapp'` to register our custom application.
*   **`DATABASES`**: Uses the default SQLite database, suitable for development.
*   **`REST_FRAMEWORK`**: This dictionary configures global DRF settings.
    *   `DEFAULT_PERMISSION_CLASSES`: Defines who can access your API. `AllowAny` is set for easy testing, but you'd typically use `IsAuthenticated` or custom permissions in production.
    *   `DEFAULT_AUTHENTICATION_CLASSES`: Specifies how users authenticate. `SessionAuthentication` and `BasicAuthentication` are enabled for browser-based access and simple API clients.
    *   `DEFAULT_PAGINATION_CLASS` & `PAGE_SIZE`: Sets up default pagination for list views.
    *   `DEFAULT_RENDERER_CLASSES`: Enables both JSON rendering (for API clients) and the Browsable API (for developers and testing in a browser).

---

$$$$ myproject
&&&& urls.py
@@@@
"""
URL configuration for myproject project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.0/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('myapp.urls')), # Include URLs from our 'myapp'
    # Optional: DRF Login/Logout views for the browsable API
    path('api-auth/', include('rest_framework.urls', namespace='rest_framework')),
]
@@@@
**Explanation:**
*   `path('admin/', admin.site.urls)`: The standard Django admin interface.
*   `path('api/', include('myapp.urls'))`: This line includes all URL patterns defined in `myapp/urls.py` under the `/api/` prefix. This keeps your project's `urls.py` clean and delegates URL handling to the specific app.
*   `path('api-auth/', include('rest_framework.urls', namespace='rest_framework'))`: This is optional but highly recommended for development. It adds login/logout URLs used by the browsable API to make authentication easier when testing in the browser.

---

$$$$ myproject
&&&& wsgi.py
@@@@
"""
WSGI config for myproject project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings')

application = get_wsgi_application()
@@@@
**Explanation:** Standard WSGI entry point for serving your Django application.

---

$$$$ myproject
&&&& asgi.py
@@@@
"""
ASGI config for myproject project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings')

application = get_asgi_application()
@@@@
**Explanation:** Standard ASGI entry point for serving your Django application (e.g., for WebSockets).

---

$$$$ myapp
&&&& __init__.py
@@@@
@@@@
**Explanation:** An empty `__init__.py` file signifies that `myapp` is a Python package.

---

$$$$ myapp
&&&& admin.py
@@@@
from django.contrib import admin
from .models import Product

# Register your models here.
@admin.register(Product)
class ProductAdmin(admin.ModelAdmin):
    list_display = ('name', 'price', 'stock', 'created_at', 'updated_at')
    search_fields = ('name', 'description')
    list_filter = ('stock', 'created_at')
    date_hierarchy = 'created_at'
@@@@
**Explanation:** This file registers the `Product` model with the Django admin interface, making it available for CRUD operations through the admin panel. `ProductAdmin` customizes how the model is displayed in the admin.

---

$$$$ myapp
&&&& apps.py
@@@@
from django.apps import AppConfig


class MyappConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'myapp'
@@@@
**Explanation:** Standard Django app configuration file. It declares the app's name and its default primary key type.

---

$$$$ myapp
&&&& models.py
@@@@
from django.db import models

class Product(models.Model):
    """
    Represents a product in an inventory system.
    """
    name = models.CharField(max_length=255, unique=True, help_text="Name of the product.")
    description = models.TextField(blank=True, help_text="Detailed description of the product.")
    price = models.DecimalField(max_digits=10, decimal_places=2, help_text="Price of the product.")
    stock = models.IntegerField(default=0, help_text="Current stock level of the product.")
    created_at = models.DateTimeField(auto_now_add=True, help_text="Timestamp when the product was created.")
    updated_at = models.DateTimeField(auto_now=True, help_text="Timestamp when the product was last updated.")

    class Meta:
        ordering = ['name']
        verbose_name = "Product"
        verbose_name_plural = "Products"

    def __str__(self):
        return self.name

    def is_in_stock(self):
        """Checks if the product has stock."""
        return self.stock > 0

    def decrease_stock(self, quantity):
        """Decreases the stock by a given quantity."""
        if self.stock >= quantity:
            self.stock -= quantity
            self.save()
            return True
        return False

    def increase_stock(self, quantity):
        """Increases the stock by a given quantity."""
        self.stock += quantity
        self.save()
        return True
@@@@
**Explanation:**
*   This defines a simple `Product` model using Django's ORM.
*   It includes common fields like `name`, `description`, `price`, and `stock`.
*   `created_at` and `updated_at` are added for auditing purposes (`auto_now_add` for creation, `auto_now` for updates).
*   `__str__` method provides a human-readable representation of the object, which is useful in the admin panel and debugging.
*   `Meta` options provide ordering and verbose names.
*   Helper methods like `is_in_stock`, `decrease_stock`, and `increase_stock` demonstrate basic business logic within the model.

---

$$$$ myapp
&&&& serializers.py
@@@@
from rest_framework import serializers
from .models import Product

class ProductSerializer(serializers.ModelSerializer):
    """
    Serializer for the Product model.
    Handles converting Product model instances to JSON and vice-versa.
    """
    # Optional: Add custom fields or modify existing ones
    # For example, a read-only field 'is_available' based on stock
    is_available = serializers.SerializerMethodField(read_only=True)

    class Meta:
        model = Product
        fields = ['id', 'name', 'description', 'price', 'stock', 'is_available', 'created_at', 'updated_at']
        read_only_fields = ['created_at', 'updated_at'] # These fields are automatically set by Django

    def get_is_available(self, obj):
        """
        Custom method to determine if a product is available (has stock).
        """
        return obj.is_in_stock()

    def validate_price(self, value):
        """
        Custom validation for the price field.
        Ensures the price is not negative.
        """
        if value < 0:
            raise serializers.ValidationError("Price cannot be negative.")
        return value

    def validate_stock(self, value):
        """
        Custom validation for the stock field.
        Ensures the stock is not negative.
        """
        if value < 0:
            raise serializers.ValidationError("Stock cannot be negative.")
        return value
@@@@
**Explanation:**
*   **`ProductSerializer(serializers.ModelSerializer)`**: This is the core of our API data representation. `ModelSerializer` is a powerful class that automatically generates fields based on your Django model.
*   **`class Meta`**:
    *   `model = Product`: Specifies which model this serializer is for.
    *   `fields = [...]`: Defines which fields from the `Product` model should be included in the API representation. `id` is usually included implicitly but good practice to explicitly list.
    *   `read_only_fields = [...]`: Fields that should be included in the API output but not modifiable by the client (e.g., `created_at`, `updated_at`).
*   **`is_available = serializers.SerializerMethodField(read_only=True)`**: Demonstrates a custom read-only field. The value is derived from a method named `get_<field_name>` (i.e., `get_is_available`).
*   **`validate_price`, `validate_stock`**: Examples of custom field-level validation. Serializers are a great place to enforce data integrity before saving to the database.

---

$$$$ myapp
&&&& views.py
@@@@
from rest_framework import viewsets
from rest_framework.permissions import AllowAny, IsAuthenticatedOrReadOnly
from .models import Product
from .serializers import ProductSerializer

class ProductViewSet(viewsets.ModelViewSet):
    """
    A ViewSet for viewing and editing product instances.
    Provides CRUD operations (Create, Retrieve, Update, Delete) for Products.
    """
    queryset = Product.objects.all().order_by('name')
    serializer_class = ProductSerializer
    permission_classes = [AllowAny] # Or use IsAuthenticatedOrReadOnly, etc.

    # Optional: Override methods for custom logic if needed
    # def perform_create(self, serializer):
    #     serializer.save(created_by=self.request.user) # Example: save creator
    #
    # def perform_update(self, serializer):
    #     serializer.save(updated_by=self.request.user) # Example: save updater

    # Optional: Custom action (e.g., to increase/decrease stock)
    # from rest_framework.decorators import action
    # from rest_framework.response import Response
    # from rest_framework import status
    #
    # @action(detail=True, methods=['post'], url_path='adjust-stock')
    # def adjust_stock(self, request, pk=None):
    #     product = self.get_object()
    #     quantity = request.data.get('quantity', 0)
    #     action_type = request.data.get('action', 'increase') # 'increase' or 'decrease'
    #
    #     try:
    #         quantity = int(quantity)
    #         if quantity < 0:
    #             return Response({"detail": "Quantity cannot be negative."}, status=status.HTTP_400_BAD_REQUEST)
    #     except ValueError:
    #         return Response({"detail": "Quantity must be an integer."}, status=status.HTTP_400_BAD_REQUEST)
    #
    #     if action_type == 'increase':
    #         product.increase_stock(quantity)
    #         message = f"Stock increased by {quantity}."
    #     elif action_type == 'decrease':
    #         if not product.decrease_stock(quantity):
    #             return Response({"detail": "Not enough stock to decrease by this quantity."}, status=status.HTTP_400_BAD_REQUEST)
    #         message = f"Stock decreased by {quantity}."
    #     else:
    #         return Response({"detail": "Invalid action type. Must be 'increase' or 'decrease'."}, status=status.HTTP_400_BAD_REQUEST)
    #
    #     serializer = self.get_serializer(product)
    #     return Response({'status': message, 'product': serializer.data}, status=status.HTTP_200_OK)
@@@@
**Explanation:**
*   **`ProductViewSet(viewsets.ModelViewSet)`**: This is the most powerful and common DRF view. `ModelViewSet` automatically provides standard CRUD (Create, Retrieve, Update, Delete) operations for a model, handling list and detail views.
*   **`queryset = Product.objects.all().order_by('name')`**: Specifies the base queryset that the view will operate on.
*   **`serializer_class = ProductSerializer`**: Links the view to its serializer, telling it how to convert `Product` objects to/from JSON.
*   **`permission_classes = [AllowAny]`**: Defines who can access the view. For production, you'd typically use `IsAuthenticated`, `IsAdminUser`, or custom permissions. `AllowAny` is good for initial development and public APIs.
*   **Commented-out code**: Shows examples of how to override `perform_create`/`perform_update` for adding custom logic during save operations (e.g., setting the creator), and how to add custom actions using the `@action` decorator to extend the API's functionality beyond standard CRUD.

---

$$$$ myapp
&&&& urls.py
@@@@
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import ProductViewSet

# Create a router and register our viewsets with it.
router = DefaultRouter()
router.register(r'products', ProductViewSet, basename='product')

# The API URLs are now determined automatically by the router.
urlpatterns = [
    path('', include(router.urls)),
]
@@@@
**Explanation:**
*   **`DefaultRouter()`**: DRF's routers automatically generate URL patterns for `ViewSet` classes. This saves a lot of manual URL configuration.
*   **`router.register(r'products', ProductViewSet, basename='product')`**: Registers our `ProductViewSet` with the router.
    *   `r'products'`: This is the URL prefix for our product API (e.g., `/api/products/`).
    *   `ProductViewSet`: The viewset to register.
    *   `basename='product'`: Used for reverse URL lookups. It's often inferred from the model name, but explicitly setting it is good practice, especially if the viewset doesn't directly map to a model.
*   **`urlpatterns = [path('', include(router.urls))]`**: Includes all the URLs generated by the router into the app's URL patterns. When combined with the project `urls.py` (`path('api/', include('myapp.urls'))`), the product API endpoints will be accessible at `/api/products/`, `/api/products/{id}/`, etc.

---

$$$$ myapp/tests
&&&& __init__.py
@@@@
@@@@
**Explanation:** An empty `__init__.py` file signifies that `myapp/tests` is a Python package.

---

$$$$ myapp/tests
&&&& test_models.py
@@@@
from django.test import TestCase
from myapp.models import Product
from decimal import Decimal

class ProductModelTest(TestCase):
    """
    Tests for the Product model.
    """
    def setUp(self):
        """
        Set up non-modified objects for every test method.
        """
        self.product1 = Product.objects.create(
            name="Laptop",
            description="Powerful laptop for coding and gaming.",
            price=Decimal('1200.00'),
            stock=10
        )
        self.product2 = Product.objects.create(
            name="Mouse",
            description="Wireless optical mouse.",
            price=Decimal('25.50'),
            stock=0
        )

    def test_product_creation(self):
        """
        Test that a product can be created and its attributes are correct.
        """
        self.assertEqual(self.product1.name, "Laptop")
        self.assertEqual(self.product1.price, Decimal('1200.00'))
        self.assertEqual(self.product1.stock, 10)
        self.assertTrue(self.product1.created_at)
        self.assertTrue(self.product1.updated_at)

    def test_str_representation(self):
        """
        Test the __str__ method of the Product model.
        """
        self.assertEqual(str(self.product1), "Laptop")

    def test_is_in_stock_method(self):
        """
        Test the is_in_stock method.
        """
        self.assertTrue(self.product1.is_in_stock())
        self.assertFalse(self.product2.is_in_stock())

    def test_decrease_stock_method(self):
        """
        Test decreasing product stock.
        """
        self.product1.decrease_stock(5)
        self.assertEqual(self.product1.stock, 5)
        self.assertFalse(self.product2.decrease_stock(1)) # Cannot decrease stock if 0
        self.assertEqual(self.product2.stock, 0) # Stock remains 0

    def test_increase_stock_method(self):
        """
        Test increasing product stock.
        """
        self.product2.increase_stock(10)
        self.assertEqual(self.product2.stock, 10)
@@@@
**Explanation:**
*   **`TestCase`**: Django's test class that provides a test database, ensuring tests don't interfere with your development database.
*   **`setUp`**: A method that runs before each test method, setting up initial data (e.g., creating `Product` instances) so each test starts with a clean slate.
*   **`test_product_creation`**: Verifies that a product can be created and its fields hold the expected values.
*   **`test_str_representation`**: Checks if the `__str__` method returns the correct string.
*   **`test_is_in_stock_method`**: Tests the custom model method `is_in_stock`.
*   **`test_decrease_stock_method`**: Tests the `decrease_stock` method, including edge cases like trying to decrease stock below zero.
*   **`test_increase_stock_method`**: Tests the `increase_stock` method.

---

$$$$ myapp/tests
&&&& test_serializers.py
@@@@
from django.test import TestCase
from myapp.models import Product
from myapp.serializers import ProductSerializer
from decimal import Decimal
import datetime

class ProductSerializerTest(TestCase):
    """
    Tests for the ProductSerializer.
    """
    def setUp(self):
        """
        Set up data for serializer tests.
        """
        self.product_data = {
            "name": "Smartphone",
            "description": "Latest model smartphone with advanced features.",
            "price": Decimal('800.00'),
            "stock": 50
        }
        self.product = Product.objects.create(**self.product_data)
        self.serializer = ProductSerializer(instance=self.product)

    def test_serializer_contains_expected_fields(self):
        """
        Verify that the serializer output contains all expected fields.
        """
        data = self.serializer.data
        self.assertCountEqual(data.keys(), ['id', 'name', 'description', 'price', 'stock', 'is_available', 'created_at', 'updated_at'])

    def test_serializer_data(self):
        """
        Verify that the serialized data matches the model instance.
        """
        data = self.serializer.data
        self.assertEqual(data['name'], self.product_data['name'])
        self.assertEqual(Decimal(data['price']), self.product_data['price']) # Convert to Decimal for exact comparison
        self.assertEqual(data['stock'], self.product_data['stock'])
        self.assertTrue(data['is_available']) # Stock is 50, so should be available

    def test_serializer_create(self):
        """
        Test creating a new product via the serializer.
        """
        new_product_data = {
            "name": "Headphones",
            "description": "Noise-cancelling headphones.",
            "price": Decimal('150.00'),
            "stock": 20
        }
        serializer = ProductSerializer(data=new_product_data)
        self.assertTrue(serializer.is_valid())
        product = serializer.save()

        self.assertEqual(product.name, new_product_data['name'])
        self.assertEqual(product.stock, new_product_data['stock'])
        self.assertTrue(product.id)

    def test_serializer_update(self):
        """
        Test updating an existing product via the serializer.
        """
        update_data = {
            "name": "Updated Smartphone Name",
            "price": Decimal('750.00'),
            "stock": 45
        }
        serializer = ProductSerializer(instance=self.product, data=update_data, partial=True)
        self.assertTrue(serializer.is_valid())
        updated_product = serializer.save()

        self.assertEqual(updated_product.name, update_data['name'])
        self.assertEqual(updated_product.price, update_data['price'])
        self.assertEqual(updated_product.stock, update_data['stock'])
        self.assertNotEqual(updated_product.updated_at, self.product.updated_at) # Check if updated_at changed

    def test_serializer_validation_negative_price(self):
        """
        Test serializer validation for negative price.
        """
        invalid_data = self.product_data.copy()
        invalid_data['name'] = "Invalid Product Price" # Unique name
        invalid_data['price'] = Decimal('-10.00')
        serializer = ProductSerializer(data=invalid_data)
        self.assertFalse(serializer.is_valid())
        self.assertIn('price', serializer.errors)
        self.assertEqual(str(serializer.errors['price'][0]), "Price cannot be negative.")

    def test_serializer_validation_negative_stock(self):
        """
        Test serializer validation for negative stock.
        """
        invalid_data = self.product_data.copy()
        invalid_data['name'] = "Invalid Product Stock" # Unique name
        invalid_data['stock'] = -5
        serializer = ProductSerializer(data=invalid_data)
        self.assertFalse(serializer.is_valid())
        self.assertIn('stock', serializer.errors)
        self.assertEqual(str(serializer.errors['stock'][0]), "Stock cannot be negative.")

    def test_serializer_read_only_fields(self):
        """
        Test that read-only fields cannot be set by the client.
        """
        read_only_data = self.product_data.copy()
        read_only_data['name'] = "Test Read Only"
        read_only_data['created_at'] = datetime.datetime(2000, 1, 1, tzinfo=datetime.timezone.utc)
        serializer = ProductSerializer(data=read_only_data)
        self.assertTrue(serializer.is_valid())
        product = serializer.save()
        # Ensure created_at is still auto_now_add and not what we tried to set
        self.assertNotEqual(product.created_at, datetime.datetime(2000, 1, 1, tzinfo=datetime.timezone.utc))

        # Test updating a read-only field
        update_read_only_data = {'updated_at': datetime.datetime(2000, 1, 1, tzinfo=datetime.timezone.utc)}
        serializer = ProductSerializer(instance=self.product, data=update_read_only_data, partial=True)
        self.assertTrue(serializer.is_valid())
        updated_product = serializer.save()
        # Ensure updated_at is still auto_now and not what we tried to set
        self.assertNotEqual(updated_product.updated_at, datetime.datetime(2000, 1, 1, tzinfo=datetime.timezone.utc))
        self.assertGreater(updated_product.updated_at, self.product.updated_at) # Should be updated by save
@@@@
**Explanation:**
*   **`ProductSerializerTest`**: Tests the functionality of `ProductSerializer`.
*   **`setUp`**: Creates a `Product` instance and initializes a `ProductSerializer` for it.
*   **`test_serializer_contains_expected_fields`**: Checks if the serializer's output (`serializer.data`) contains all the fields defined in `Meta.fields`.
*   **`test_serializer_data`**: Verifies that the serialized data correctly matches the model's data, including the custom `is_available` field.
*   **`test_serializer_create`**: Simulates creating a new object through the serializer, ensuring `is_valid()` and `save()` work as expected.
*   **`test_serializer_update`**: Simulates updating an existing object. `partial=True` allows for partial updates.
*   **`test_serializer_validation_negative_price`/`_stock`**: Tests the custom validation logic implemented in the serializer to prevent negative values.
*   **`test_serializer_read_only_fields`**: Confirms that fields marked as `read_only_fields` cannot be modified by providing data during create or update operations.

---

$$$$ myapp/tests
&&&& test_views.py
@@@@
from django.urls import reverse
from rest_framework import status
from rest_framework.test import APITestCase, APIClient
from myapp.models import Product
from myapp.serializers import ProductSerializer
from decimal import Decimal

class ProductAPITest(APITestCase):
    """
    Tests for the Product API endpoints using ProductViewSet.
    """
    def setUp(self):
        """
        Set up an API client and some initial product data for tests.
        """
        self.client = APIClient()
        self.product1 = Product.objects.create(
            name="Test Product 1",
            description="Description for Test Product 1",
            price=Decimal('100.00'),
            stock=10
        )
        self.product2 = Product.objects.create(
            name="Test Product 2",
            description="Description for Test Product 2",
            price=Decimal('200.00'),
            stock=0
        )
        self.list_url = reverse('product-list') # 'product-list' is generated by DefaultRouter for ProductViewSet
        self.detail_url = reverse('product-detail', kwargs={'pk': self.product1.id}) # 'product-detail'

    def test_get_product_list(self):
        """
        Ensure we can retrieve a list of products.
        """
        response = self.client.get(self.list_url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        # Check that both products are in the response
        self.assertEqual(len(response.data['results']), 2) # DefaultRouter often adds pagination
        serializer = ProductSerializer(Product.objects.all().order_by('name'), many=True)
        # Compare sorted serialized data, especially useful with pagination
        self.assertEqual(response.data['results'], serializer.data)

    def test_get_single_product(self):
        """
        Ensure we can retrieve a single product by ID.
        """
        response = self.client.get(self.detail_url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        serializer = ProductSerializer(self.product1)
        self.assertEqual(response.data, serializer.data)

    def test_create_product(self):
        """
        Ensure we can create a new product.
        """
        data = {
            "name": "New Product",
            "description": "A brand new product.",
            "price": Decimal('50.00'),
            "stock": 5
        }
        response = self.client.post(self.list_url, data, format='json')
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(Product.objects.count(), 3) # Two initial + one new
        self.assertEqual(Product.objects.get(name="New Product").stock, 5)

    def test_create_product_invalid_data(self):
        """
        Ensure we cannot create a product with invalid data (e.g., negative price).
        """
        data = {
            "name": "Invalid Product",
            "description": "Product with invalid price.",
            "price": Decimal('-10.00'), # Invalid price
            "stock": 10
        }
        response = self.client.post(self.list_url, data, format='json')
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn('price', response.data)
        self.assertEqual(Product.objects.count(), 2) # No new product created

    def test_update_product(self):
        """
        Ensure we can update an existing product.
        """
        update_data = {
            "name": "Updated Product Name",
            "price": Decimal('120.00'),
            "stock": 15
        }
        response = self.client.put(self.detail_url, update_data, format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.product1.refresh_from_db() # Reload product data from the database
        self.assertEqual(self.product1.name, "Updated Product Name")
        self.assertEqual(self.product1.price, Decimal('120.00'))
        self.assertEqual(self.product1.stock, 15)

    def test_partial_update_product(self):
        """
        Ensure we can partially update an existing product using PATCH.
        """
        partial_update_data = {
            "stock": 8
        }
        response = self.client.patch(self.detail_url, partial_update_data, format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.product1.refresh_from_db()
        self.assertEqual(self.product1.stock, 8)
        self.assertEqual(self.product1.name, "Test Product 1") # Name should remain unchanged

    def test_delete_product(self):
        """
        Ensure we can delete a product.
        """
        response = self.client.delete(self.detail_url)
        self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT)
        self.assertEqual(Product.objects.count(), 1) # Only product2 remains
        with self.assertRaises(Product.DoesNotExist):
            Product.objects.get(id=self.product1.id)
@@@@
**Explanation:**
*   **`APITestCase`**: DRF's test class which extends Django's `TestCase` and provides an `APIClient` for making requests to your API.
*   **`setUp`**: Initializes `APIClient` and creates some initial `Product` instances. It also uses `reverse` to get the actual URLs for the list and detail views, making the tests more robust against URL changes.
    *   `'product-list'` and `'product-detail'` are the names generated by `DefaultRouter` for the `ProductViewSet`.
*   **`test_get_product_list`**: Simulates an HTTP GET request to the list endpoint and asserts the status code and the structure/content of the response data (including checking for pagination).
*   **`test_get_single_product`**: Simulates a GET request to a detail endpoint.
*   **`test_create_product`**: Simulates an HTTP POST request to create a new resource, asserting the `201 Created` status and checking if the object was actually saved.
*   **`test_create_product_invalid_data`**: Tests the API's response to invalid input, ensuring a `400 Bad Request` and appropriate error messages.
*   **`test_update_product`**: Simulates an HTTP PUT request for a full update. `refresh_from_db()` is essential here to load the latest state of the object after the update.
*   **`test_partial_update_product`**: Simulates an HTTP PATCH request for a partial update.
*   **`test_delete_product`**: Simulates an HTTP DELETE request, asserting the `204 No Content` status and verifying the object is removed from the database.

---

**How to use this template:**

1.  **Create your project and app folders:**
    You would typically start by running:
    ```bash
    django-admin startproject myproject
    cd myproject
    python manage.py startapp myapp
    ```
2.  **Install Django REST Framework:**
    ```bash
    pip install djangorestframework
    ```
3.  **Copy the code into the respective files.**
4.  **Run migrations:**
    ```bash
    python manage.py makemigrations myapp
    python manage.py migrate
    ```
5.  **Create a superuser to access the Django Admin (optional):**
    ```bash
    python manage.py createsuperuser
    ```
6.  **Run the development server:**
    ```bash
    python manage.py runserver
    ```
    You can then access the API at `http://127.0.0.1:8000/api/products/` and the browsable API at `http://127.0.0.1:8000/api/products/` in your browser.
7.  **Run the unit tests:**
    ```bash
    python manage.py test myapp
    ```

This template provides a solid foundation for building a robust REST API with Django and DRF. Remember to adapt the models, serializers, and views to fit your specific application's requirements.