Here is a complete code template for a Python Django Rest Framework application, including models, serializers, views, URLs, and unit tests.

This template will create a simple API for managing "Products".

**Project Structure Overview:**

```
myproject/
├── manage.py
├── myproject/
│   ├── __init__.py
│   ├── asgi.py
│   ├── settings.py
│   ├── urls.py
│   └── wsgi.py
└── myapp/
    ├── __init__.py
    ├── admin.py
    ├── apps.py
    ├── migrations/
    │   └── __init__.py
    ├── models.py
    ├── serializers.py
    ├── tests.py
    ├── urls.py
    └── views.py
```

---

**1. Project Setup (Root Level)**

$$$$
&&&& manage.py
@@@@
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()
@@@@
**Explanation:** This is the standard `manage.py` file generated by Django. It's the entry point for running Django commands like `runserver`, `makemigrations`, `migrate`, `test`, etc.

---

**2. Project Configuration**

$$$$ myproject/
&&&& __init__.py
@@@@
# This file marks the 'myproject' directory as a Python package.
@@@@
**Explanation:** Standard Python package initializer.

$$$$ myproject/
&&&& settings.py
@@@@
"""
Django settings for myproject project.

Generated by 'django-admin startproject' using Django 5.0.6.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.0/ref/settings/
"""

from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-j%871r@s7+p-k00@+g*a%v9t!*r7x98%1&e7^t060d*5p%e7' # Replace with a strong, unique key in production!

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Third-party apps
    'rest_framework', # Django REST Framework
    # My apps
    'myapp', # Your custom application
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'myproject.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'myproject.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.0/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.0/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.0/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.0/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# Django REST Framework settings
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.SessionAuthentication',
        'rest_framework.authentication.BasicAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticatedOrReadOnly', # Allow read for anonymous, write for authenticated
    ],
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10, # Number of items per page for pagination
}
@@@@
**Explanation:**
*   `INSTALLED_APPS`: We've added `'rest_framework'` and `'myapp'` to enable DRF and our custom application.
*   `DATABASES`: Uses a default SQLite database, suitable for development.
*   `REST_FRAMEWORK`: This dictionary configures DRF:
    *   `DEFAULT_AUTHENTICATION_CLASSES`: Specifies authentication methods. `SessionAuthentication` is good for browser-based APIs, and `BasicAuthentication` provides simple username/password.
    *   `DEFAULT_PERMISSION_CLASSES`: Defines global permissions. `IsAuthenticatedOrReadOnly` allows unauthenticated users to perform read-only actions (GET, HEAD, OPTIONS) but requires authentication for write actions (POST, PUT, PATCH, DELETE).
    *   `DEFAULT_PAGINATION_CLASS` and `PAGE_SIZE`: Configures global pagination for list views, returning 10 items per page by default.

$$$$ myproject/
&&&& urls.py
@@@@
"""
URL configuration for myproject project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.0/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('myapp.urls')), # Include URLs from your 'myapp'
    path('api-auth/', include('rest_framework.urls')), # DRF login/logout views for browsable API
]
@@@@
**Explanation:**
*   `path('admin/', admin.site.urls)`: Default Django admin interface.
*   `path('api/', include('myapp.urls'))`: This line routes all URLs starting with `/api/` to `myapp/urls.py`, where our API endpoints will be defined.
*   `path('api-auth/', include('rest_framework.urls'))`: This is crucial for the DRF browsable API. It adds login/logout views, allowing you to authenticate directly from the browser when interacting with your API endpoints.

$$$$ myproject/
&&&& wsgi.py
@@@@
"""
WSGI config for myproject project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings')

application = get_wsgi_application()
@@@@
**Explanation:** Standard WSGI entry point for serving the application.

$$$$ myproject/
&&&& asgi.py
@@@@
"""
ASGI config for myproject project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'myproject.settings')

application = get_asgi_application()
@@@@
**Explanation:** Standard ASGI entry point for serving the application (e.g., for WebSockets).

---

**3. Application (`myapp`)**

$$$$ myapp/
&&&& __init__.py
@@@@
# This file marks the 'myapp' directory as a Python package.
@@@@
**Explanation:** Standard Python package initializer.

$$$$ myapp/
&&&& admin.py
@@@@
from django.contrib import admin
from .models import Product

@admin.register(Product)
class ProductAdmin(admin.ModelAdmin):
    """
    Admin configuration for the Product model.
    Displays 'name', 'price', and 'created_at' in the list view.
    Allows searching by 'name' and 'description'.
    """
    list_display = ('name', 'price', 'created_at', 'updated_at')
    search_fields = ('name', 'description')
    list_filter = ('created_at', 'updated_at') # Add filtering options
    readonly_fields = ('created_at', 'updated_at') # Make these fields read-only in the admin
@@@@
**Explanation:** This file registers the `Product` model with the Django admin interface, making it available for management through `http://127.0.0.1:8000/admin/`. The `ProductAdmin` class customizes how the model is displayed in the admin.

$$$$ myapp/
&&&& apps.py
@@@@
from django.apps import AppConfig


class MyappConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'myapp'
@@@@
**Explanation:** Standard Django application configuration.

$$$$ myapp/
&&&& models.py
@@@@
from django.db import models

class Product(models.Model):
    """
    Represents a product in the inventory.
    """
    name = models.CharField(max_length=255, unique=True, help_text="Name of the product")
    description = models.TextField(blank=True, null=True, help_text="Detailed description of the product")
    price = models.DecimalField(max_digits=10, decimal_places=2, help_text="Price of the product")
    is_available = models.BooleanField(default=True, help_text="Is the product currently available for purchase?")
    created_at = models.DateTimeField(auto_now_add=True, help_text="Timestamp when the product was created")
    updated_at = models.DateTimeField(auto_now=True, help_text="Timestamp when the product was last updated")

    class Meta:
        ordering = ['name'] # Default ordering for querysets
        verbose_name = "Product"
        verbose_name_plural = "Products"

    def __str__(self):
        """
        String representation of the Product object.
        """
        return f"{self.name} (${self.price})"

    def save(self, *args, **kwargs):
        """
        Custom save method can be added here if needed, e.g., for pre-processing.
        """
        super().save(*args, **kwargs)

    def is_expensive(self):
        """
        Example of a custom model method.
        """
        return self.price > 100
@@@@
**Explanation:**
*   `Product` Model: Defines the structure of our `Product` objects.
    *   `name`: A `CharField` (string) for the product name, required and unique.
    *   `description`: A `TextField` for longer text, optional.
    *   `price`: A `DecimalField` for precise monetary values.
    *   `is_available`: A `BooleanField` to track availability.
    *   `created_at`: A `DateTimeField` that automatically sets the creation timestamp.
    *   `updated_at`: A `DateTimeField` that automatically updates the timestamp on every save.
*   `Meta` class: Provides model-specific options like default ordering and verbose names.
*   `__str__`: Returns a human-readable string representation of the object, useful in the admin and debugging.

$$$$ myapp/
&&&& serializers.py
@@@@
from rest_framework import serializers
from .models import Product

class ProductSerializer(serializers.ModelSerializer):
    """
    Serializer for the Product model.
    Converts Product model instances to JSON representations and vice-versa.
    """
    # Custom field example: Add a read-only field that indicates if the product is expensive
    is_expensive_product = serializers.SerializerMethodField(read_only=True)

    class Meta:
        model = Product
        fields = [
            'id', 'name', 'description', 'price',
            'is_available', 'created_at', 'updated_at',
            'is_expensive_product'
        ]
        read_only_fields = ['created_at', 'updated_at'] # These fields are set by the model, not by user input

    def get_is_expensive_product(self, obj):
        """
        Returns True if the product's price is greater than 100, False otherwise.
        This method is called for the 'is_expensive_product' SerializerMethodField.
        """
        return obj.is_expensive() # Leverage the model method

    def validate_price(self, value):
        """
        Custom validation for the price field.
        Ensures the price is not negative.
        """
        if value < 0:
            raise serializers.ValidationError("Price cannot be negative.")
        return value

    def create(self, validated_data):
        """
        Override create if you need custom logic for saving new instances.
        """
        return super().create(validated_data)

    def update(self, instance, validated_data):
        """
        Override update if you need custom logic for updating existing instances.
        """
        return super().update(instance, validated_data)
@@@@
**Explanation:**
*   `ProductSerializer`: This class defines how `Product` model instances are converted into JSON (serialization) and how incoming JSON data is converted into `Product` instances (deserialization and validation).
*   `serializers.ModelSerializer`: A powerful class that automatically maps model fields to serializer fields.
*   `Meta` class:
    *   `model = Product`: Links the serializer to the `Product` model.
    *   `fields`: Specifies which fields from the model should be included in the API representation. `'id'` is usually included.
    *   `read_only_fields`: Fields that should be included in the output but not editable via the API (e.g., auto-generated timestamps).
*   `is_expensive_product = serializers.SerializerMethodField`: This is an example of adding a custom read-only field to the serializer that doesn't exist directly on the model. Its value is derived from the `get_is_expensive_product` method.
*   `validate_price`: An example of field-level validation, ensuring the price is non-negative.

$$$$ myapp/
&&&& views.py
@@@@
from rest_framework import viewsets, status
from rest_framework.response import Response
from rest_framework.decorators import action
from .models import Product
from .serializers import ProductSerializer

class ProductViewSet(viewsets.ModelViewSet):
    """
    A ViewSet for viewing and editing Product instances.
    Provides standard CRUD operations: list, create, retrieve, update, partial_update, destroy.
    """
    queryset = Product.objects.all().order_by('name') # All products, ordered by name
    serializer_class = ProductSerializer

    # You can add custom actions to your ViewSet
    @action(detail=True, methods=['post'], name='Set Availability')
    def set_availability(self, request, pk=None):
        """
        Custom action to set the availability status of a product.
        Usage: POST /api/products/{id}/set_availability/
        Body: {"is_available": true/false}
        """
        product = self.get_object()
        is_available = request.data.get('is_available')

        if is_available is None or not isinstance(is_available, bool):
            return Response(
                {"detail": "Please provide a boolean value for 'is_available'."},
                status=status.HTTP_400_BAD_REQUEST
            )

        product.is_available = is_available
        product.save()
        serializer = self.get_serializer(product)
        return Response(serializer.data, status=status.HTTP_200_OK)

    @action(detail=False, methods=['get'], name='Available Products')
    def available(self, request):
        """
        Custom action to list only available products.
        Usage: GET /api/products/available/
        """
        available_products = self.get_queryset().filter(is_available=True)
        page = self.paginate_queryset(available_products)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)

        serializer = self.get_serializer(available_products, many=True)
        return Response(serializer.data)
@@@@
**Explanation:**
*   `ProductViewSet`: This class handles all HTTP requests for our `Product` model.
*   `viewsets.ModelViewSet`: A powerful DRF class that automatically provides CRUD (Create, Retrieve, Update, Delete) operations for a model. It maps HTTP methods (GET, POST, PUT, PATCH, DELETE) to corresponding actions.
*   `queryset`: Specifies the base queryset that the viewset will use to retrieve objects. We fetch all `Product` objects and order them by `name`.
*   `serializer_class`: Links the viewset to our `ProductSerializer`.
*   `@action`: Decorator for adding custom actions to a `ViewSet`.
    *   `set_availability`: A detail action (`detail=True`) that operates on a single product instance. It allows changing `is_available` via a POST request.
    *   `available`: A list action (`detail=False`) that operates on the collection of products. It filters and returns only available products.

$$$$ myapp/
&&&& urls.py
@@@@
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import ProductViewSet

# Create a router and register our ViewSets with it.
router = DefaultRouter()
router.register(r'products', ProductViewSet, basename='product')

# The API URLs are now determined automatically by the router.
urlpatterns = [
    path('', include(router.urls)),
]
@@@@
**Explanation:**
*   `DefaultRouter`: A DRF router that automatically generates URL patterns for `ViewSet` actions. This is very convenient as it saves you from manually writing URL patterns for each CRUD operation.
*   `router.register(r'products', ProductViewSet, basename='product')`: Registers our `ProductViewSet` with the router.
    *   `r'products'`: The URL prefix for this viewset (e.g., `/api/products/`, `/api/products/{id}/`).
    *   `ProductViewSet`: The viewset to register.
    *   `basename='product'`: Used to reverse URLs (e.g., `reverse('product-list')`, `reverse('product-detail', args=[1])`). It's important to set this when the viewset doesn't have a `queryset` attribute (though `ModelViewSet` usually does).

---

**4. Unit Tests**

$$$$ myapp/
&&&& tests.py
@@@@
from django.test import TestCase
from django.urls import reverse
from rest_framework import status
from rest_framework.test import APITestCase, APIClient
from django.contrib.auth.models import User

from .models import Product
from .serializers import ProductSerializer

# --- Model Tests ---
class ProductModelTest(TestCase):
    """
    Tests for the Product model.
    """
    def setUp(self):
        """
        Set up non-modified objects used by all test methods.
        """
        self.product1 = Product.objects.create(
            name="Test Product 1",
            description="Description for test product 1",
            price=19.99,
            is_available=True
        )
        self.product2 = Product.objects.create(
            name="Test Product 2",
            description="Another product",
            price=120.50,
            is_available=False
        )

    def test_product_creation(self):
        """
        Ensure product can be created and properties are correct.
        """
        self.assertEqual(Product.objects.count(), 2)
        self.assertEqual(self.product1.name, "Test Product 1")
        self.assertEqual(float(self.product1.price), 19.99) # Convert Decimal to float for comparison
        self.assertTrue(self.product1.is_available)
        self.assertIsNotNone(self.product1.created_at)
        self.assertIsNotNone(self.product1.updated_at)

    def test_product_str_representation(self):
        """
        Ensure the __str__ method returns the correct string.
        """
        self.assertEqual(str(self.product1), "Test Product 1 ($19.99)")

    def test_is_expensive_method(self):
        """
        Ensure the custom is_expensive method works correctly.
        """
        self.assertFalse(self.product1.is_expensive())
        self.assertTrue(self.product2.is_expensive())

    def test_unique_name_constraint(self):
        """
        Ensure product names are unique.
        """
        with self.assertRaises(Exception): # Expecting an IntegrityError or similar
            Product.objects.create(
                name="Test Product 1", # Duplicate name
                price=5.00
            )

# --- Serializer Tests ---
class ProductSerializerTest(TestCase):
    """
    Tests for the ProductSerializer.
    """
    def setUp(self):
        self.product_data = {
            'name': 'New Product',
            'description': 'A fantastic new item.',
            'price': 25.00,
            'is_available': True,
        }
        self.product = Product.objects.create(**self.product_data)
        self.product_serializer = ProductSerializer(instance=self.product)

    def test_serializer_contains_expected_fields(self):
        """
        Ensure the serializer output contains all expected fields.
        """
        data = self.product_serializer.data
        self.assertCountEqual(data.keys(), [
            'id', 'name', 'description', 'price',
            'is_available', 'created_at', 'updated_at',
            'is_expensive_product'
        ])

    def test_serializer_field_content(self):
        """
        Ensure the serializer output for fields matches the model instance.
        """
        data = self.product_serializer.data
        self.assertEqual(data['name'], self.product.name)
        self.assertEqual(data['description'], self.product.description)
        self.assertEqual(float(data['price']), float(self.product.price)) # Compare floats
        self.assertEqual(data['is_available'], self.product.is_available)
        # Check custom field
        self.assertEqual(data['is_expensive_product'], self.product.is_expensive())

    def test_serializer_validation_for_negative_price(self):
        """
        Ensure serializer rejects negative prices.
        """
        invalid_data = self.product_data.copy()
        invalid_data['price'] = -10.00
        serializer = ProductSerializer(data=invalid_data)
        self.assertFalse(serializer.is_valid())
        self.assertIn('price', serializer.errors)
        self.assertEqual(
            serializer.errors['price'][0], "Price cannot be negative."
        )

    def test_serializer_valid_data(self):
        """
        Ensure serializer accepts valid data and creates an instance.
        """
        new_product_data = {
            'name': 'Another Product',
            'description': 'Just another one.',
            'price': 50.00,
            'is_available': False,
        }
        serializer = ProductSerializer(data=new_product_data)
        self.assertTrue(serializer.is_valid(), serializer.errors) # Print errors if not valid
        product = serializer.save()
        self.assertEqual(product.name, 'Another Product')
        self.assertEqual(Product.objects.count(), 2)

    def test_serializer_read_only_fields(self):
        """
        Ensure read-only fields are not modifiable through the serializer.
        """
        updated_data = {
            'name': 'Updated Product Name',
            'created_at': '2000-01-01T00:00:00Z', # Attempt to change read-only field
            'updated_at': '2000-01-01T00:00:00Z', # Attempt to change read-only field
        }
        serializer = ProductSerializer(instance=self.product, data=updated_data, partial=True)
        self.assertTrue(serializer.is_valid(), serializer.errors)
        product = serializer.save()

        # The timestamps should not have changed to the provided values
        self.assertNotEqual(product.created_at.isoformat(), '2000-01-01T00:00:00Z')
        self.assertNotEqual(product.updated_at.isoformat(), '2000-01-01T00:00:00Z')
        # Only the 'name' should have been updated
        self.assertEqual(product.name, 'Updated Product Name')


# --- ViewSet Tests ---
class ProductViewSetTest(APITestCase):
    """
    Tests for the ProductViewSet.
    Uses APITestCase to make API requests.
    """
    def setUp(self):
        """
        Set up data and client for API tests.
        """
        self.user = User.objects.create_user(username='testuser', password='testpassword')
        self.admin_user = User.objects.create_superuser(username='admin', password='adminpassword')

        # Products for testing
        self.product1 = Product.objects.create(
            name="Test Product A", description="Desc A", price=10.00, is_available=True
        )
        self.product2 = Product.objects.create(
            name="Test Product B", description="Desc B", price=200.00, is_available=False
        )
        self.product_list_url = reverse('product-list')
        self.product_detail_url = reverse('product-detail', args=[self.product1.id])
        self.product1_set_availability_url = reverse('product-set-availability', args=[self.product1.id])
        self.available_products_url = reverse('product-available')


    def test_list_products(self):
        """
        Ensure we can retrieve a list of products.
        """
        response = self.client.get(self.product_list_url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data['results']), 2) # Check against 'results' for paginated output

    def test_create_product_authenticated(self):
        """
        Ensure an authenticated user can create a product.
        """
        self.client.force_authenticate(user=self.user)
        data = {'name': 'New Gadget', 'description': 'Cool item', 'price': 99.99, 'is_available': True}
        response = self.client.post(self.product_list_url, data, format='json')
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(Product.objects.count(), 3)
        self.assertEqual(Product.objects.get(name='New Gadget').price, 99.99)

    def test_create_product_unauthenticated(self):
        """
        Ensure an unauthenticated user cannot create a product (due to IsAuthenticatedOrReadOnly).
        """
        data = {'name': 'Forbidden Gadget', 'description': 'Forbidden item', 'price': 10.00, 'is_available': True}
        response = self.client.post(self.product_list_url, data, format='json')
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
        self.assertEqual(Product.objects.count(), 2) # No new product created

    def test_retrieve_product(self):
        """
        Ensure we can retrieve a single product.
        """
        response = self.client.get(self.product_detail_url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['name'], self.product1.name)

    def test_update_product_authenticated(self):
        """
        Ensure an authenticated user can update a product.
        """
        self.client.force_authenticate(user=self.user)
        updated_data = {'name': 'Updated Product A', 'price': 15.00}
        response = self.client.patch(self.product_detail_url, updated_data, format='json') # Use PATCH for partial update
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.product1.refresh_from_db()
        self.assertEqual(self.product1.name, 'Updated Product A')
        self.assertEqual(float(self.product1.price), 15.00)

    def test_update_product_unauthenticated(self):
        """
        Ensure an unauthenticated user cannot update a product.
        """
        updated_data = {'name': 'Unauthorized Update', 'price': 15.00}
        response = self.client.patch(self.product_detail_url, updated_data, format='json')
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
        self.product1.refresh_from_db()
        self.assertNotEqual(self.product1.name, 'Unauthorized Update')

    def test_delete_product_authenticated(self):
        """
        Ensure an authenticated user can delete a product.
        """
        self.client.force_authenticate(user=self.user)
        response = self.client.delete(self.product_detail_url)
        self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT)
        self.assertEqual(Product.objects.count(), 1)
        self.assertFalse(Product.objects.filter(id=self.product1.id).exists())

    def test_delete_product_unauthenticated(self):
        """
        Ensure an unauthenticated user cannot delete a product.
        """
        response = self.client.delete(self.product_detail_url)
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
        self.assertEqual(Product.objects.count(), 2) # Product should still exist

    def test_set_availability_action(self):
        """
        Ensure the custom 'set_availability' action works.
        """
        self.client.force_authenticate(user=self.user)
        response = self.client.post(self.product1_set_availability_url, {'is_available': False}, format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.product1.refresh_from_db()
        self.assertFalse(self.product1.is_available)
        self.assertEqual(response.data['id'], self.product1.id)

    def test_set_availability_action_invalid_data(self):
        """
        Ensure the 'set_availability' action handles invalid data.
        """
        self.client.force_authenticate(user=self.user)
        response = self.client.post(self.product1_set_availability_url, {'is_available': 'not_a_bool'}, format='json')
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn("Please provide a boolean value for 'is_available'.", response.data['detail'])

    def test_available_products_action(self):
        """
        Ensure the custom 'available' action lists only available products.
        """
        response = self.client.get(self.available_products_url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        # Only product1 is available in setUp
        self.assertEqual(len(response.data['results']), 1)
        self.assertEqual(response.data['results'][0]['name'], self.product1.name)

        # Make product2 available and re-test
        self.product2.is_available = True
        self.product2.save()
        response = self.client.get(self.available_products_url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data['results']), 2)


# --- Initial setup to run tests ---
# To run these tests:
# 1. Make sure you have Django and DRF installed.
# 2. Set up your Django project and app as described above.
# 3. Run `python manage.py makemigrations`
# 4. Run `python manage.py migrate`
# 5. Run `python manage.py test myapp`
@@@@
**Explanation:**
This file contains three classes for different types of tests:

*   **`ProductModelTest`**:
    *   Inherits from `django.test.TestCase`.
    *   Tests the `Product` model's basic functionality: creation, `__str__` method, custom methods (`is_expensive`), and unique constraints.
    *   `setUp`: Creates initial `Product` objects that can be used across multiple test methods.

*   **`ProductSerializerTest`**:
    *   Inherits from `django.test.TestCase`.
    *   Tests the `ProductSerializer`'s functionality:
        *   Ensures all expected fields are present in the serialized output.
        *   Verifies that field content matches the model.
        *   Tests custom validation rules (e.g., negative price).
        *   Tests serialization and deserialization with valid data.
        *   Confirms read-only fields are not modifiable.

*   **`ProductViewSetTest`**:
    *   Inherits from `rest_framework.test.APITestCase`. This class provides a test client (`self.client`) specifically designed for making HTTP requests to DRF views, handling authentication, and parsing JSON responses.
    *   Tests the `ProductViewSet`'s API endpoints:
        *   **List**: `GET` to `/api/products/`
        *   **Create**: `POST` to `/api/products/` (tests both authenticated and unauthenticated scenarios, given `IsAuthenticatedOrReadOnly` permissions)
        *   **Retrieve**: `GET` to `/api/products/{id}/`
        *   **Update**: `PATCH` to `/api/products/{id}/` (tests both authenticated and unauthenticated)
        *   **Delete**: `DELETE` to `/api/products/{id}/` (tests both authenticated and unauthenticated)
        *   **Custom Actions**: Tests `set_availability` and `available` actions.
    *   `setUp`: Creates test users (`self.user`, `self.admin_user`) and products, and uses `reverse` to get correct URLs for API endpoints.
    *   `self.client.force_authenticate(user=self.user)`: Used to simulate an authenticated user for requests.
    *   `status.HTTP_XXX_XXX`: DRF's convenient way to refer to HTTP status codes.

**To run these tests:**

1.  **Install Django and DRF:**
    `pip install Django djangorestframework`
2.  **Create project and app (if you haven't already with the manual steps above):**
    `django-admin startproject myproject`
    `cd myproject`
    `python manage.py startapp myapp`
3.  **Place the generated files into their respective directories.**
4.  **Create a superuser for admin access (optional, but good for testing admin interface):**
    `python manage.py createsuperuser`
5.  **Apply migrations:**
    `python manage.py makemigrations`
    `python manage.py migrate`
6.  **Run the tests:**
    `python manage.py test myapp`