Hello there! I'd be happy to help you generate a comprehensive Django REST Framework (DRF) code template, complete with project structure, app components, and unit tests. This template will set up a basic API for managing "Items".

This template will include:
*   A basic Django project setup.
*   A Django app named `myapp`.
*   A `Item` model within `myapp`.
*   A `ItemSerializer` to convert `Item` objects to/from JSON.
*   A `ItemViewSet` for CRUD operations on `Item` using DRF's `ModelViewSet`.
*   URL configurations for the API using `DefaultRouter`.
*   Admin registration for the `Item` model.
*   Unit tests for the `Item` API endpoints.

Let's get started!

$$$$
&&&& manage.py
@@@@
#!/usr/bin/env python
"""Django's command-line utility for administrative tasks."""
import os
import sys


def main():
    """Run administrative tasks."""
    os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'MyProject.settings')
    try:
        from django.core.management import execute_from_command_line
    except ImportError as exc:
        raise ImportError(
            "Couldn't import Django. Are you sure it's installed and "
            "available on your PYTHONPATH environment variable? Did you "
            "forget to activate a virtual environment?"
        ) from exc
    execute_from_command_line(sys.argv)


if __name__ == '__main__':
    main()
@@@@
Explanation: This is the standard Django `manage.py` script. It's used to run various Django commands like `runserver`, `makemigrations`, `migrate`, `createsuperuser`, `test`, etc.

$$$$ MyProject
&&&& __init__.py
@@@@
# This file marks the MyProject directory as a Python package.
@@@@
Explanation: An empty `__init__.py` file tells Python that the `MyProject` directory is a Python package, allowing its modules to be imported.

$$$$ MyProject
&&&& settings.py
@@@@
"""
Django settings for MyProject project.

Generated by 'django-admin startproject' using Django 5.0.6.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.0/ref/settings/
"""

import os
from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.0/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-z*m8r59!c&0w=y9=a(7-x*s09=2(7n*9w@x920a0b!9-x920a0b!'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

ALLOWED_HOSTS = []


# Application definition

INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Third-party apps
    'rest_framework', # Django REST Framework
    'corsheaders',    # For handling CORS (Cross-Origin Resource Sharing)

    # My apps
    'myapp', # My custom Django app
]

MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'corsheaders.middleware.CorsMiddleware', # CORS middleware
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

ROOT_URLCONF = 'MyProject.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'MyProject.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.0/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.0/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.0/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.0/howto/static-files/

STATIC_URL = 'static/'

# Default primary key field type
# https://docs.djangoproject.com/en/5.0/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# Django REST Framework Settings
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        'rest_framework.authentication.SessionAuthentication',
        'rest_framework.authentication.TokenAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        'rest_framework.permissions.IsAuthenticatedOrReadOnly', # Allows read-only access for unauthenticated users
    ],
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    'PAGE_SIZE': 10,
    'DEFAULT_FILTER_BACKENDS': [
        'django_filters.rest_framework.DjangoFilterBackend'
    ],
}

# CORS Headers Settings (for local development/testing)
# In production, specify CORS_ALLOWED_ORIGINS
CORS_ALLOW_ALL_ORIGINS = True # Be very specific in production!
# For production, you might use:
# CORS_ALLOWED_ORIGINS = [
#     "https://example.com",
#     "https://sub.example.com",
#     "http://localhost:3000",
#     "http://127.0.0.1:8000",
# ]

# A common way to handle static files for production is to collect them into a single directory.
# STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')
@@@@
Explanation: This is the core configuration file for your Django project.
*   **`INSTALLED_APPS`**: We've added `rest_framework` for DRF functionality, `corsheaders` for cross-origin requests, and `myapp` for our custom application.
*   **`MIDDLEWARE`**: `corsheaders.middleware.CorsMiddleware` is added for handling CORS.
*   **`DATABASES`**: Uses a default SQLite database, suitable for development.
*   **`REST_FRAMEWORK`**: Configures DRF global settings:
    *   `DEFAULT_AUTHENTICATION_CLASSES`: Specifies authentication methods (Session and Token).
    *   `DEFAULT_PERMISSION_CLASSES`: Sets a default permission to allow read-only access for unauthenticated users and full access for authenticated users.
    *   `DEFAULT_PAGINATION_CLASS`: Enables pagination for API list views.
    *   `DEFAULT_FILTER_BACKENDS`: Configures filtering support (requires `django-filter` to be installed: `pip install django-filter`).
*   **`CORS_ALLOW_ALL_ORIGINS = True`**: This is set for development convenience. **For production, you must restrict this to specific origins for security reasons.**

$$$$ MyProject
&&&& urls.py
@@@@
"""
URL configuration for MyProject project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.0/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('myapp.urls')), # Include URLs from 'myapp' under '/api/'
]
@@@@
Explanation: This is the root URL configuration for your Django project.
*   `path('admin/', admin.site.urls)`: Sets up the Django admin interface.
*   `path('api/', include('myapp.urls'))`: This is crucial. It tells Django to look for additional URL patterns in `myapp.urls` whenever a request comes in for `/api/`. This keeps your project's `urls.py` clean and delegates API routing to the app.

$$$$ MyProject
&&&& wsgi.py
@@@@
"""
WSGI config for MyProject project.

It exposes the WSGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/howto/deployment/wsgi/
"""

import os

from django.core.wsgi import get_wsgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'MyProject.settings')

application = get_wsgi_application()
@@@@
Explanation: This file is used to define how your Django application communicates with a WSGI-compatible web server (like Gunicorn or uWSGI). It's typically used in production deployments.

$$$$ MyProject
&&&& asgi.py
@@@@
"""
ASGI config for MyProject project.

It exposes the ASGI callable as a module-level variable named ``application``.

For more information on this file, see
https://docs.djangoproject.com/en/5.0/howto/deployment/asgi/
"""

import os

from django.core.asgi import get_asgi_application

os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'MyProject.settings')

application = get_asgi_application()
@@@@
Explanation: Similar to `wsgi.py`, this file is for asynchronous web server gateway interface (ASGI) support, often used for websockets or other async features. If you're not using async features, you might not need to configure this further.

$$$$ myapp
&&&& __init__.py
@@@@
# This file marks the myapp directory as a Python package.
@@@@
Explanation: Marks `myapp` as a Python package.

$$$$ myapp
&&&& admin.py
@@@@
from django.contrib import admin
from .models import Item

# Register your models here.
@admin.register(Item)
class ItemAdmin(admin.ModelAdmin):
    list_display = ('name', 'price', 'created_at', 'updated_at')
    list_filter = ('created_at', 'updated_at')
    search_fields = ('name', 'description')
    date_hierarchy = 'created_at'
    ordering = ('-created_at',)
@@@@
Explanation: This file registers your `Item` model with the Django administrative interface.
*   `@admin.register(Item)`: A decorator to register the `Item` model.
*   `ItemAdmin`: Customizes how the `Item` model appears in the admin. `list_display` shows specific fields in the list view, `list_filter` adds sidebar filters, `search_fields` enables searching, and `date_hierarchy` provides date-based navigation.

$$$$ myapp
&&&& apps.py
@@@@
from django.apps import AppConfig


class MyappConfig(AppConfig):
    default_auto_field = 'django.db.models.BigAutoField'
    name = 'myapp'
@@@@
Explanation: This file defines the configuration for your `myapp` application. `default_auto_field` specifies the type of primary key to be used for models in this app.

$$$$ myapp
&&&& models.py
@@@@
from django.db import models

class Item(models.Model):
    """
    A simple model to represent an item with basic properties.
    """
    name = models.CharField(max_length=255, unique=True, help_text="Name of the item")
    description = models.TextField(blank=True, null=True, help_text="Detailed description of the item")
    price = models.DecimalField(max_digits=10, decimal_places=2, help_text="Price of the item")
    is_available = models.BooleanField(default=True, help_text="Is the item currently available for purchase?")
    created_at = models.DateTimeField(auto_now_add=True, help_text="Timestamp when the item was created")
    updated_at = models.DateTimeField(auto_now=True, help_text="Timestamp when the item was last updated")

    class Meta:
        ordering = ['name'] # Default ordering for querysets
        verbose_name = "Item"
        verbose_name_plural = "Items"

    def __str__(self):
        return self.name

    def save(self, *args, **kwargs):
        # Example of custom save logic if needed
        super().save(*args, **kwargs)
@@@@
Explanation: This file defines your database models.
*   `Item` model: Represents an item with fields like `name`, `description`, `price`, `is_available`, `created_at`, and `updated_at`.
*   `CharField`, `TextField`, `DecimalField`, `BooleanField`, `DateTimeField`: Common Django field types.
*   `unique=True`: Ensures no two items have the same name.
*   `auto_now_add=True`: Automatically sets the creation timestamp.
*   `auto_now=True`: Automatically updates the timestamp on every save.
*   `class Meta`: Provides model-specific options, like default ordering.
*   `__str__` method: Defines the string representation of an object, useful for the admin panel and debugging.

$$$$ myapp
&&&& serializers.py
@@@@
from rest_framework import serializers
from .models import Item

class ItemSerializer(serializers.ModelSerializer):
    """
    Serializer for the Item model.
    Converts Item model instances to JSON representations and vice-versa.
    """
    # You can add custom fields here if they don't directly map to model fields
    # For example, a read-only field:
    # item_status = serializers.SerializerMethodField()

    class Meta:
        model = Item
        fields = ['id', 'name', 'description', 'price', 'is_available', 'created_at', 'updated_at']
        # read_only_fields = ['created_at', 'updated_at'] # Optional: make these fields read-only on updates

    # Example of a SerializerMethodField implementation
    # def get_item_status(self, obj):
    #     if obj.is_available:
    #         return "In Stock"
    #     return "Out of Stock"

    # Custom validation example (for the whole serializer)
    def validate(self, data):
        """
        Check that the price is not negative.
        """
        if data.get('price') is not None and data['price'] < 0:
            raise serializers.ValidationError({"price": "Price cannot be negative."})
        return data

    # Custom validation example (for a single field)
    def validate_name(self, value):
        """
        Check that the name is not just whitespace.
        """
        if not value.strip():
            raise serializers.ValidationError("Item name cannot be empty or just whitespace.")
        return value
@@@@
Explanation: Serializers are a core component of DRF, converting complex Django model instances into native Python datatypes that can then be easily rendered into JSON, XML, or other content types.
*   `ItemSerializer(serializers.ModelSerializer)`: This class automatically generates fields based on the `Item` model and provides `create()` and `update()` methods.
*   `class Meta`:
    *   `model = Item`: Specifies the model to serialize.
    *   `fields = [...]`: Lists the fields from the model that should be included in the serialized output. `id` is typically included for API operations.
*   **Custom Validation**: Examples for `validate` (object-level) and `validate_name` (field-level) are included to demonstrate data validation before saving.

$$$$ myapp
&&&& views.py
@@@@
from rest_framework import viewsets, permissions, filters
from rest_framework.decorators import action
from rest_framework.response import Response
from django_filters.rest_framework import DjangoFilterBackend
from .models import Item
from .serializers import ItemSerializer

class ItemViewSet(viewsets.ModelViewSet):
    """
    API endpoint that allows items to be viewed or edited.
    Provides CRUD operations for the Item model.
    """
    queryset = Item.objects.all().order_by('-created_at')
    serializer_class = ItemSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly] # Only authenticated users can create/update/delete

    # Optional: Add filtering capabilities
    filter_backends = [DjangoFilterBackend, filters.SearchFilter, filters.OrderingFilter]
    filterset_fields = ['is_available', 'price'] # Fields to allow exact match filtering
    search_fields = ['name', 'description']      # Fields to allow searching (case-insensitive)
    ordering_fields = ['name', 'price', 'created_at'] # Fields to allow ordering

    # Custom action example: Mark an item as unavailable
    @action(detail=True, methods=['post'], permission_classes=[permissions.IsAdminUser])
    def mark_unavailable(self, request, pk=None):
        item = self.get_object()
        item.is_available = False
        item.save()
        serializer = self.get_serializer(item)
        return Response(serializer.data)

    # Custom action example: List available items (on the list route)
    @action(detail=False, methods=['get'])
    def available_items(self, request):
        available = Item.objects.filter(is_available=True)
        serializer = self.get_serializer(available, many=True)
        return Response(serializer.data)

    # You can override methods like `perform_create`, `perform_update`, `perform_destroy`
    # def perform_create(self, serializer):
    #     # Example: Set owner of the item to the requesting user
    #     serializer.save(owner=self.request.user)
@@@@
Explanation: ViewSets simplify the process of building API views by providing a set of common operations (CRUD).
*   `ItemViewSet(viewsets.ModelViewSet)`: This viewset automatically handles listing, retrieving, creating, updating, and deleting `Item` instances.
*   `queryset`: Specifies the base queryset for the viewset.
*   `serializer_class`: Links the viewset to its serializer.
*   `permission_classes`: Defines who can access the API. `IsAuthenticatedOrReadOnly` allows anyone to read data, but only authenticated users can modify it.
*   **Filtering, Searching, Ordering**: `filter_backends`, `filterset_fields`, `search_fields`, and `ordering_fields` are configured to add powerful data manipulation capabilities to your API. Remember to `pip install django-filter`.
*   **Custom Actions**: `mark_unavailable` and `available_items` demonstrate how to add custom endpoint actions to your viewset, accessible at `/api/items/{id}/mark_unavailable/` and `/api/items/available_items/` respectively.

$$$$ myapp
&&&& urls.py
@@@@
from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import ItemViewSet

# Create a router and register our viewsets with it.
router = DefaultRouter()
router.register(r'items', ItemViewSet, basename='item')

# The API URLs are now determined automatically by the router.
urlpatterns = [
    path('', include(router.urls)),
]
@@@@
Explanation: This file defines the URL patterns for your `myapp` API.
*   `DefaultRouter`: DRF's `DefaultRouter` automatically generates URL patterns for `ModelViewSet`s. This includes routes for listing, creating, retrieving, updating, and deleting objects.
*   `router.register(r'items', ItemViewSet, basename='item')`: Registers the `ItemViewSet` under the `/items/` endpoint. `basename` is used for reverse URL lookup.
*   `path('', include(router.urls))`: Includes all URLs generated by the router at the root of `myapp`'s URL space (which is `/api/` from the project's `urls.py`). So, the full path to items will be `/api/items/`.

$$$$ myapp
&&&& tests.py
@@@@
from rest_framework.test import APITestCase
from rest_framework import status
from django.urls import reverse
from django.contrib.auth import get_user_model
from decimal import Decimal
from .models import Item

User = get_user_model()

class ItemAPITestCase(APITestCase):
    """
    Test suite for the Item API endpoints.
    """

    def setUp(self):
        """
        Set up common test data and users.
        """
        # Create a regular user
        self.user = User.objects.create_user(username='testuser', password='testpassword')
        # Create an admin user for admin-only actions
        self.admin_user = User.objects.create_superuser(username='admin', password='adminpassword', email='admin@example.com')

        # Create some test items
        self.item1 = Item.objects.create(name='Laptop', description='Powerful laptop', price=Decimal('1200.00'), is_available=True)
        self.item2 = Item.objects.create(name='Mouse', description='Wireless mouse', price=Decimal('25.50'), is_available=False)

        # URLs for the API
        self.list_url = reverse('item-list') # 'item' is the basename defined in myapp/urls.py
        self.detail_url = reverse('item-detail', args=[self.item1.id])
        self.mark_unavailable_url = reverse('item-mark-unavailable', args=[self.item1.id])
        self.available_items_url = reverse('item-available-items')

    def test_create_item_authenticated(self):
        """
        Ensure an authenticated user can create a new item.
        """
        self.client.force_authenticate(user=self.user)
        data = {'name': 'Keyboard', 'description': 'Mechanical keyboard', 'price': '150.00', 'is_available': True}
        response = self.client.post(self.list_url, data, format='json')
        self.assertEqual(response.status_code, status.HTTP_201_CREATED)
        self.assertEqual(Item.objects.count(), 3)
        self.assertEqual(Item.objects.get(name='Keyboard').price, Decimal('150.00'))

    def test_create_item_unauthenticated(self):
        """
        Ensure an unauthenticated user cannot create a new item.
        """
        data = {'name': 'Monitor', 'description': '4K Monitor', 'price': '400.00'}
        response = self.client.post(self.list_url, data, format='json')
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
        self.assertEqual(Item.objects.count(), 2)

    def test_list_items(self):
        """
        Ensure we can retrieve a list of items (unauthenticated allowed).
        """
        response = self.client.get(self.list_url, format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data['results']), 2) # Check 'results' due to pagination
        # Check if ordering is applied (descending by created_at)
        self.assertEqual(response.data['results'][0]['name'], self.item2.name) # Item 2 might have been created last depending on creation speed
        self.assertEqual(response.data['results'][1]['name'], self.item1.name)

    def test_retrieve_item_detail(self):
        """
        Ensure we can retrieve a single item (unauthenticated allowed).
        """
        response = self.client.get(self.detail_url, format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['name'], self.item1.name)
        self.assertEqual(Decimal(response.data['price']), self.item1.price)

    def test_update_item_authenticated(self):
        """
        Ensure an authenticated user can update an item.
        """
        self.client.force_authenticate(user=self.user)
        updated_data = {'name': 'Updated Laptop', 'description': 'Even more powerful', 'price': '1300.00', 'is_available': False}
        response = self.client.put(self.detail_url, updated_data, format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.item1.refresh_from_db()
        self.assertEqual(self.item1.name, 'Updated Laptop')
        self.assertEqual(self.item1.price, Decimal('1300.00'))
        self.assertFalse(self.item1.is_available)

    def test_update_item_unauthenticated(self):
        """
        Ensure an unauthenticated user cannot update an item.
        """
        updated_data = {'name': 'Attempted Update', 'price': '999.99'}
        response = self.client.put(self.detail_url, updated_data, format='json')
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
        self.item1.refresh_from_db()
        self.assertNotEqual(self.item1.name, 'Attempted Update')

    def test_partial_update_item_authenticated(self):
        """
        Ensure an authenticated user can partially update an item.
        """
        self.client.force_authenticate(user=self.user)
        partial_data = {'price': '1250.00'}
        response = self.client.patch(self.detail_url, partial_data, format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.item1.refresh_from_db()
        self.assertEqual(self.item1.price, Decimal('1250.00'))
        self.assertEqual(self.item1.name, 'Laptop') # Name should remain unchanged

    def test_delete_item_authenticated(self):
        """
        Ensure an authenticated user can delete an item.
        """
        self.client.force_authenticate(user=self.user)
        response = self.client.delete(self.detail_url)
        self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT)
        self.assertEqual(Item.objects.count(), 1)
        self.assertFalse(Item.objects.filter(id=self.item1.id).exists())

    def test_delete_item_unauthenticated(self):
        """
        Ensure an unauthenticated user cannot delete an item.
        """
        response = self.client.delete(self.detail_url)
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
        self.assertEqual(Item.objects.count(), 2)

    def test_filter_items_by_availability(self):
        """
        Ensure items can be filtered by 'is_available'.
        """
        response = self.client.get(self.list_url + '?is_available=True', format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data['results']), 1)
        self.assertEqual(response.data['results'][0]['name'], self.item1.name) # Laptop is available

    def test_search_items_by_name(self):
        """
        Ensure items can be searched by 'name'.
        """
        response = self.client.get(self.list_url + '?search=Mouse', format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data['results']), 1)
        self.assertEqual(response.data['results'][0]['name'], self.item2.name)

    def test_ordering_items_by_price(self):
        """
        Ensure items can be ordered by 'price'.
        """
        # Order by price ascending
        response = self.client.get(self.list_url + '?ordering=price', format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['results'][0]['name'], self.item2.name) # Mouse (25.50) first
        self.assertEqual(response.data['results'][1]['name'], self.item1.name) # Laptop (1200.00) second

        # Order by price descending
        response = self.client.get(self.list_url + '?ordering=-price', format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['results'][0]['name'], self.item1.name) # Laptop first
        self.assertEqual(response.data['results'][1]['name'], self.item2.name) # Mouse second

    def test_mark_unavailable_action_admin_user(self):
        """
        Ensure an admin user can mark an item as unavailable.
        """
        self.client.force_authenticate(user=self.admin_user)
        response = self.client.post(self.mark_unavailable_url, format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.item1.refresh_from_db()
        self.assertFalse(self.item1.is_available)
        self.assertEqual(response.data['name'], self.item1.name)

    def test_mark_unavailable_action_regular_user(self):
        """
        Ensure a regular authenticated user cannot mark an item as unavailable.
        """
        self.client.force_authenticate(user=self.user)
        response = self.client.post(self.mark_unavailable_url, format='json')
        self.assertEqual(response.status_code, status.HTTP_403_FORBIDDEN) # Forbidden for non-admin
        self.item1.refresh_from_db()
        self.assertTrue(self.item1.is_available) # Should remain available

    def test_mark_unavailable_action_unauthenticated(self):
        """
        Ensure an unauthenticated user cannot mark an item as unavailable.
        """
        response = self.client.post(self.mark_unavailable_url, format='json')
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
        self.item1.refresh_from_db()
        self.assertTrue(self.item1.is_available)

    def test_available_items_action(self):
        """
        Ensure the 'available_items' custom action works.
        """
        response = self.client.get(self.available_items_url, format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 1)
        self.assertEqual(response.data[0]['name'], self.item1.name)
        self.assertTrue(response.data[0]['is_available'])

        # Mark item1 unavailable to check again
        self.item1.is_available = False
        self.item1.save()
        response = self.client.get(self.available_items_url, format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(len(response.data), 0) # Now no items are available

    def test_create_item_with_invalid_price(self):
        """
        Ensure item creation fails with a negative price.
        """
        self.client.force_authenticate(user=self.user)
        data = {'name': 'Invalid Item', 'description': 'Test negative price', 'price': '-10.00'}
        response = self.client.post(self.list_url, data, format='json')
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn("Price cannot be negative.", response.data['price'][0])
        self.assertEqual(Item.objects.count(), 2) # No new item created

    def test_create_item_with_empty_name(self):
        """
        Ensure item creation fails with an empty or whitespace name.
        """
        self.client.force_authenticate(user=self.user)
        data = {'name': '   ', 'description': 'Empty name', 'price': '10.00'}
        response = self.client.post(self.list_url, data, format='json')
        self.assertEqual(response.status_code, status.HTTP_400_BAD_REQUEST)
        self.assertIn("Item name cannot be empty or just whitespace.", response.data['name'][0])
        self.assertEqual(Item.objects.count(), 2)
@@@@
Explanation: This file contains unit tests for your API using DRF's `APITestCase`.
*   `setUp()`: Initializes common data like users and test `Item` objects, and generates API URLs using `reverse()` for robust testing.
*   **Authentication**: `self.client.force_authenticate(user=self.user)` is used to simulate an authenticated request. Requests without this are unauthenticated.
*   **Test Methods**: Each method (`test_create_item_authenticated`, `test_list_items`, etc.) focuses on a specific API behavior:
    *   **CRUD operations**: Testing POST (create), GET (list/retrieve), PUT (full update), PATCH (partial update), DELETE.
    *   **Permissions**: Verifying that authenticated users can perform certain actions while unauthenticated users cannot.
    *   **Filtering, Searching, Ordering**: Testing the functionality added in `ItemViewSet`.
    *   **Custom Actions**: Testing the `mark_unavailable` and `available_items` actions.
    *   **Validation**: Testing custom validation rules defined in `ItemSerializer`.
*   **Assertions**: `self.assertEqual(response.status_code, status.HTTP_201_CREATED)` checks the HTTP status code, `self.assertEqual(Item.objects.count(), 3)` checks database state, and `self.assertIn` checks error messages.

---

**To use this template:**

1.  **Save the files** according to the folder structure provided.
    *   Create a root directory (e.g., `my_drf_project`).
    *   Place `manage.py` directly in the root.
    *   Create `MyProject` folder and place its contents inside.
    *   Create `myapp` folder and place its contents inside.
2.  **Create a virtual environment** and activate it:
    ```bash
    python -m venv venv
    # On Windows
    .\venv\Scripts\activate
    # On macOS/Linux
    source venv/bin/activate
    ```
3.  **Install Django and DRF** and other dependencies:
    ```bash
    pip install Django djangorestframework django-cors-headers django-filter
    ```
4.  **Apply migrations**:
    ```bash
    python manage.py makemigrations myapp
    python manage.py migrate
    ```
5.  **Create a superuser** (for admin access):
    ```bash
    python manage.py createsuperuser
    ```
6.  **Run the development server**:
    ```bash
    python manage.py runserver
    ```
    You can now access the API at `http://127.0.0.1:8000/api/items/` and the admin panel at `http://127.0.0.1:8000/admin/`.
7.  **Run tests**:
    ```bash
    python manage.py test myapp
    ```

This template provides a solid foundation for building RESTful APIs with Django and DRF. Remember to adapt the models, serializers, and views to your specific project requirements!