Hello there! I'd be happy to help you with a comprehensive Spring Boot REST API code template, including unit tests and explanations.

This template will demonstrate a simple CRUD (Create, Read, Update, Delete) API for a `Product` entity.

### Project Setup (Conceptual)

This template assumes a standard Spring Boot project structure, typically generated by Spring Initializr with dependencies like:
*   **Spring Web**: For building RESTful applications.
*   **Spring Data JPA**: For database interaction.
*   **H2 Database**: An in-memory database, great for development and testing.
*   **Lombok**: Reduces boilerplate code (optional, but widely used).
*   **Spring Boot DevTools**: For development conveniences (optional).

### Code Template

$$$$
$$$$src
$$$$src/main
$$$$src/main/java
$$$$src/main/java/com
$$$$src/main/java/com/example
$$$$src/main/java/com/example/demo
&&&&DemoApplication.java
@@@@
package com.example.demo;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * Main entry point for the Spring Boot application.
 *
 * @SpringBootApplication: This annotation combines:
 *   - @Configuration: Tags the class as a source of bean definitions for the application context.
 *   - @EnableAutoConfiguration: Tells Spring Boot to start adding beans based on classpath settings,
 *     other beans, and various property settings.
 *   - @ComponentScan: Tells Spring to look for other components, configurations, and services
 *     in the `com.example.demo` package, allowing it to find controllers, services, repositories, etc.
 */
@SpringBootApplication
public class DemoApplication {

    public static void main(String[] args) {
        SpringApplication.run(DemoApplication.class, args);
    }

}
@@@@

$$$$src/main/java/com/example/demo/model
&&&&Product.java
@@@@
package com.example.demo.model;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * Represents the Product entity in the database.
 *
 * @Entity: Marks this class as a JPA entity, meaning it maps to a database table.
 * @Table: Specifies the name of the database table if it's different from the class name.
 * @Data: A Lombok annotation that bundles @ToString, @EqualsAndHashCode, @Getter, @Setter, and @RequiredArgsConstructor.
 *        It automatically generates getters, setters, toString(), equals(), and hashCode() methods.
 * @NoArgsConstructor: A Lombok annotation that generates a constructor with no arguments.
 * @AllArgsConstructor: A Lombok annotation that generates a constructor with all arguments.
 */
@Entity
@Table(name = "products")
@Data
@NoArgsConstructor
@AllArgsConstructor
public class Product {

    /**
     * Unique identifier for the product.
     * @Id: Marks this field as the primary key of the entity.
     * @GeneratedValue: Specifies the strategy for primary key generation.
     *   - GenerationType.IDENTITY: Indicates that the persistence provider must assign primary keys
     *     for the entity using a database identity column.
     */
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    /**
     * Name of the product.
     * @Column: Specifies the mapped column for the persistent property or field.
     *   - nullable = false: Indicates that the column cannot contain null values.
     *   - unique = true: Indicates that the column must have unique values (for product name, this might be optional
     *     or based on business rules, but good for demonstration).
     */
    @Column(nullable = false, unique = true)
    private String name;

    /**
     * Description of the product.
     * @Column: Allows defining properties of the column like length.
     */
    @Column(length = 500)
    private String description;

    /**
     * Price of the product.
     * @Column: Allows defining properties of the column like precision and scale for decimal numbers.
     */
    @Column(nullable = false, precision = 10, scale = 2)
    private Double price;

    /**
     * Default constructor (required by JPA for proxy creation, but also generated by Lombok's @NoArgsConstructor).
     */
    // You can remove this explicit constructor if using Lombok's @NoArgsConstructor
    // public Product() {
    // }

    /**
     * Constructor for creating a new product without an ID (ID will be generated by the database).
     */
    public Product(String name, String description, Double price) {
        this.name = name;
        this.description = description;
        this.price = price;
    }
}
@@@@

$$$$src/main/java/com/example/demo/dto
&&&&ProductRequest.java
@@@@
package com.example.demo.dto;

import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Positive;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO (Data Transfer Object) for creating or updating a product.
 * Used to encapsulate request data, providing validation and decoupling the API from the internal entity structure.
 *
 * @Data: Lombok annotation for getters, setters, equals, hashCode, and toString.
 * @NoArgsConstructor: Lombok annotation for a no-argument constructor.
 * @AllArgsConstructor: Lombok annotation for an all-argument constructor.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProductRequest {

    /**
     * Name of the product.
     * @NotBlank: Validates that the string is not null and the trimmed length is greater than zero.
     */
    @NotBlank(message = "Product name is required")
    private String name;

    /**
     * Description of the product.
     * No specific validation here, as it can be optional or empty.
     */
    private String description;

    /**
     * Price of the product.
     * @NotNull: Validates that the value is not null.
     * @Positive: Validates that the numeric value is strictly positive.
     */
    @NotNull(message = "Product price is required")
    @Positive(message = "Product price must be positive")
    private Double price;
}
@@@@

$$$$src/main/java/com/example/demo/dto
&&&&ProductResponse.java
@@@@
package com.example.demo.dto;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

/**
 * DTO (Data Transfer Object) for sending product details as a response.
 * This can be useful to hide certain entity fields (e.g., sensitive data) or to combine fields
 * from multiple entities, decoupling the API response from the internal entity structure.
 *
 * @Data: Lombok annotation for getters, setters, equals, hashCode, and toString.
 * @NoArgsConstructor: Lombok annotation for a no-argument constructor.
 * @AllArgsConstructor: Lombok annotation for an all-argument constructor.
 */
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ProductResponse {
    /**
     * Unique identifier for the product.
     */
    private Long id;

    /**
     * Name of the product.
     */
    private String name;

    /**
     * Description of the product.
     */
    private String description;

    /**
     * Price of the product.
     */
    private Double price;
}
@@@@

$$$$src/main/java/com/example/demo/repository
&&&&ProductRepository.java
@@@@
package com.example.demo.repository;

import com.example.demo.model.Product;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

/**
 * Repository interface for Product entities.
 *
 * @Repository: Indicates that an annotated class is a "Repository",
 * which is a mechanism for encapsulating storage, retrieval, and search behavior
 * which emulates a collection of objects. Spring Data JPA automatically provides
 * an implementation at runtime.
 *
 * JpaRepository<Product, Long>: Extends JpaRepository, providing standard CRUD operations
 * and pagination/sorting capabilities for the Product entity with Long as its primary key type.
 */
@Repository
public interface ProductRepository extends JpaRepository<Product, Long> {
    // Custom query methods can be added here if needed,
    // e.g., Optional<Product> findByName(String name);
}
@@@@

$$$$src/main/java/com/example/demo/exception
&&&&ResourceNotFoundException.java
@@@@
package com.example.demo.exception;

import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ResponseStatus;

/**
 * Custom exception to indicate that a resource (e.g., Product) was not found.
 *
 * @ResponseStatus: Causes Spring to return the specified HTTP status code (404 NOT FOUND)
 * whenever this exception is thrown from a controller method.
 */
@ResponseStatus(HttpStatus.NOT_FOUND)
public class ResourceNotFoundException extends RuntimeException {

    /**
     * Constructs a new ResourceNotFoundException with the specified detail message.
     *
     * @param message The detail message (e.g., "Product not found with id: 123").
     */
    public ResourceNotFoundException(String message) {
        super(message);
    }
}
@@@@

$$$$src/main/java/com/example/demo/exception
&&&&GlobalExceptionHandler.java
@@@@
package com.example.demo.exception;

import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ControllerAdvice;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.context.request.WebRequest;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

/**
 * Global exception handler for the application.
 *
 * @ControllerAdvice: This annotation allows handling exceptions across the whole application
 * in a centralized way. It can be used to define global @ExceptionHandler, @InitBinder, and @ModelAttribute methods.
 */
@ControllerAdvice
public class GlobalExceptionHandler {

    /**
     * Handles ResourceNotFoundException.
     * Returns an HTTP 404 Not Found status with a custom error message.
     *
     * @param ex The ResourceNotFoundException instance.
     * @param request The current web request.
     * @return A ResponseEntity containing error details and HTTP status.
     */
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorDetails> handleResourceNotFoundException(ResourceNotFoundException ex, WebRequest request) {
        ErrorDetails errorDetails = new ErrorDetails(
                LocalDateTime.now(),
                ex.getMessage(),
                request.getDescription(false),
                "NOT_FOUND"
        );
        return new ResponseEntity<>(errorDetails, HttpStatus.NOT_FOUND);
    }

    /**
     * Handles MethodArgumentNotValidException (validation errors for @RequestBody).
     * Returns an HTTP 400 Bad Request status with detailed validation error messages.
     *
     * @param ex The MethodArgumentNotValidException instance.
     * @param request The current web request.
     * @return A ResponseEntity containing validation error details and HTTP status.
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<Object> handleMethodArgumentNotValid(MethodArgumentNotValidException ex, WebRequest request) {
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getFieldErrors().forEach(error ->
                errors.put(error.getField(), error.getDefaultMessage()));

        ErrorDetails errorDetails = new ErrorDetails(
                LocalDateTime.now(),
                "Validation Failed",
                request.getDescription(false),
                "BAD_REQUEST",
                errors
        );
        return new ResponseEntity<>(errorDetails, HttpStatus.BAD_REQUEST);
    }

    /**
     * Handles all other uncaught exceptions.
     * Returns an HTTP 500 Internal Server Error status.
     *
     * @param ex The general Exception instance.
     * @param request The current web request.
     * @return A ResponseEntity containing generic error details and HTTP status.
     */
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorDetails> handleGlobalException(Exception ex, WebRequest request) {
        ErrorDetails errorDetails = new ErrorDetails(
                LocalDateTime.now(),
                ex.getMessage(),
                request.getDescription(false),
                "INTERNAL_SERVER_ERROR"
        );
        return new ResponseEntity<>(errorDetails, HttpStatus.INTERNAL_SERVER_ERROR);
    }

    /**
     * Helper class to structure error responses.
     */
    public static class ErrorDetails {
        private LocalDateTime timestamp;
        private String message;
        private String details;
        private String errorCode;
        private Map<String, String> validationErrors; // Optional, for validation errors

        public ErrorDetails(LocalDateTime timestamp, String message, String details, String errorCode) {
            this.timestamp = timestamp;
            this.message = message;
            this.details = details;
            this.errorCode = errorCode;
        }

        public ErrorDetails(LocalDateTime timestamp, String message, String details, String errorCode, Map<String, String> validationErrors) {
            this.timestamp = timestamp;
            this.message = message;
            this.details = details;
            this.errorCode = errorCode;
            this.validationErrors = validationErrors;
        }

        public LocalDateTime getTimestamp() { return timestamp; }
        public String getMessage() { return message; }
        public String getDetails() { return details; }
        public String getErrorCode() { return errorCode; }
        public Map<String, String> getValidationErrors() { return validationErrors; }
    }
}
@@@@

$$$$src/main/java/com/example/demo/service
&&&&ProductService.java
@@@@
package com.example.demo.service;

import com.example.demo.dto.ProductRequest;
import com.example.demo.dto.ProductResponse;
import com.example.demo.exception.ResourceNotFoundException;
import com.example.demo.model.Product;
import com.example.demo.repository.ProductRepository;
import lombok.RequiredArgsConstructor;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.stream.Collectors;

/**
 * Service layer for managing Product entities.
 * This layer encapsulates business logic and interacts with the repository.
 *
 * @Service: Marks this class as a Spring Service, indicating it holds business logic.
 * @RequiredArgsConstructor: A Lombok annotation that generates a constructor with
 *                          arguments for all fields marked with 'final'. This is
 *                          a convenient way to achieve constructor-based dependency injection.
 */
@Service
@RequiredArgsConstructor
public class ProductService {

    private final ProductRepository productRepository;

    /**
     * Converts a Product entity to a ProductResponse DTO.
     * @param product The Product entity to convert.
     * @return The corresponding ProductResponse DTO.
     */
    private ProductResponse mapToProductResponse(Product product) {
        return new ProductResponse(product.getId(), product.getName(), product.getDescription(), product.getPrice());
    }

    /**
     * Retrieves all products.
     *
     * @return A list of ProductResponse DTOs.
     * @Transactional(readOnly = true): Indicates that the method only reads from the database.
     *                                 Spring optimizes read-only transactions for performance.
     */
    @Transactional(readOnly = true)
    public List<ProductResponse> getAllProducts() {
        List<Product> products = productRepository.findAll();
        return products.stream()
                .map(this::mapToProductResponse)
                .collect(Collectors.toList());
    }

    /**
     * Retrieves a product by its ID.
     *
     * @param id The ID of the product.
     * @return The ProductResponse DTO if found.
     * @throws ResourceNotFoundException If no product is found with the given ID.
     * @Transactional(readOnly = true): Indicates that the method only reads from the database.
     */
    @Transactional(readOnly = true)
    public ProductResponse getProductById(Long id) {
        Product product = productRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Product not found with id: " + id));
        return mapToProductResponse(product);
    }

    /**
     * Creates a new product.
     *
     * @param productRequest The ProductRequest DTO containing product details.
     * @return The ProductResponse DTO of the newly created product.
     * @Transactional: Indicates that the method should be executed within a transaction.
     *                 If the method completes successfully, the transaction is committed;
     *                 otherwise, it is rolled back.
     */
    @Transactional
    public ProductResponse createProduct(ProductRequest productRequest) {
        Product product = new Product(
                productRequest.getName(),
                productRequest.getDescription(),
                productRequest.getPrice()
        );
        Product savedProduct = productRepository.save(product);
        return mapToProductResponse(savedProduct);
    }

    /**
     * Updates an existing product.
     *
     * @param id The ID of the product to update.
     * @param productRequest The ProductRequest DTO containing updated product details.
     * @return The ProductResponse DTO of the updated product.
     * @throws ResourceNotFoundException If no product is found with the given ID.
     * @Transactional: Ensures atomicity of the update operation.
     */
    @Transactional
    public ProductResponse updateProduct(Long id, ProductRequest productRequest) {
        Product existingProduct = productRepository.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("Product not found with id: " + id));

        existingProduct.setName(productRequest.getName());
        existingProduct.setDescription(productRequest.getDescription());
        existingProduct.setPrice(productRequest.getPrice());

        Product updatedProduct = productRepository.save(existingProduct);
        return mapToProductResponse(updatedProduct);
    }

    /**
     * Deletes a product by its ID.
     *
     * @param id The ID of the product to delete.
     * @throws ResourceNotFoundException If no product is found with the given ID.
     * @Transactional: Ensures atomicity of the delete operation.
     */
    @Transactional
    public void deleteProduct(Long id) {
        if (!productRepository.existsById(id)) {
            throw new ResourceNotFoundException("Product not found with id: " + id);
        }
        productRepository.deleteById(id);
    }
}
@@@@

$$$$src/main/java/com/example/demo/controller
&&&&ProductController.java
@@@@
package com.example.demo.controller;

import com.example.demo.dto.ProductRequest;
import com.example.demo.dto.ProductResponse;
import com.example.demo.service.ProductService;
import jakarta.validation.Valid;
import lombok.RequiredArgsConstructor;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;

/**
 * REST Controller for Product management.
 * Handles incoming HTTP requests and delegates to the ProductService for business logic.
 *
 * @RestController: A convenience annotation that combines @Controller and @ResponseBody.
 *                 It's specialized for building RESTful web services.
 * @RequestMapping: Maps HTTP requests to handler methods. Here, all methods in this
 *                  controller will be prefixed with "/api/products".
 * @RequiredArgsConstructor: Lombok annotation for constructor injection of final fields.
 */
@RestController
@RequestMapping("/api/products")
@RequiredArgsConstructor
public class ProductController {

    private final ProductService productService;

    /**
     * Handles GET requests to retrieve all products.
     *
     * @return A ResponseEntity containing a list of ProductResponse DTOs and HTTP status 200 OK.
     */
    @GetMapping
    public ResponseEntity<List<ProductResponse>> getAllProducts() {
        List<ProductResponse> products = productService.getAllProducts();
        return ResponseEntity.ok(products); // Or return new ResponseEntity<>(products, HttpStatus.OK);
    }

    /**
     * Handles GET requests to retrieve a single product by its ID.
     *
     * @param id The ID of the product to retrieve. Extracted from the URL path.
     * @return A ResponseEntity containing the ProductResponse DTO and HTTP status 200 OK.
     *         Throws ResourceNotFoundException if product is not found, handled by GlobalExceptionHandler.
     */
    @GetMapping("/{id}")
    public ResponseEntity<ProductResponse> getProductById(@PathVariable Long id) {
        ProductResponse product = productService.getProductById(id);
        return ResponseEntity.ok(product);
    }

    /**
     * Handles POST requests to create a new product.
     *
     * @param productRequest The ProductRequest DTO containing product details, sent in the request body.
     *                       @Valid: Triggers validation on the DTO based on JSR-303 annotations (e.g., @NotBlank, @NotNull).
     * @return A ResponseEntity containing the newly created ProductResponse DTO and HTTP status 201 CREATED.
     */
    @PostMapping
    public ResponseEntity<ProductResponse> createProduct(@Valid @RequestBody ProductRequest productRequest) {
        ProductResponse createdProduct = productService.createProduct(productRequest);
        return new ResponseEntity<>(createdProduct, HttpStatus.CREATED);
    }

    /**
     * Handles PUT requests to update an existing product.
     *
     * @param id The ID of the product to update.
     * @param productRequest The ProductRequest DTO containing updated product details.
     * @return A ResponseEntity containing the updated ProductResponse DTO and HTTP status 200 OK.
     *         Throws ResourceNotFoundException if product is not found, handled by GlobalExceptionHandler.
     */
    @PutMapping("/{id}")
    public ResponseEntity<ProductResponse> updateProduct(@PathVariable Long id, @Valid @RequestBody ProductRequest productRequest) {
        ProductResponse updatedProduct = productService.updateProduct(id, productRequest);
        return ResponseEntity.ok(updatedProduct);
    }

    /**
     * Handles DELETE requests to delete a product by its ID.
     *
     * @param id The ID of the product to delete.
     * @return A ResponseEntity with no content and HTTP status 204 NO_CONTENT.
     *         Throws ResourceNotFoundException if product is not found, handled by GlobalExceptionHandler.
     */
    @DeleteMapping("/{id}")
    public ResponseEntity<Void> deleteProduct(@PathVariable Long id) {
        productService.deleteProduct(id);
        return ResponseEntity.noContent().build(); // HTTP 204 No Content
    }
}
@@@@

$$$$src/main/resources
&&&&application.properties
@@@@
# Application Port
server.port=8080

# H2 Database Configuration
# In-memory database, data will be lost when application restarts
spring.datasource.url=jdbc:h2:mem:demodb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE
spring.datasource.driverClassName=org.h2.Driver
spring.datasource.username=sa
spring.datasource.password=password

# JPA/Hibernate Configuration
# 'update' mode creates/updates schema based on entities. 'create-drop' would drop on exit.
spring.jpa.hibernate.ddl-auto=update
# Shows SQL queries in console (useful for debugging)
spring.jpa.show-sql=true
# Formats the SQL queries for better readability
spring.jpa.properties.hibernate.format_sql=true
# Set the dialect for H2 database
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect

# H2 Console Configuration (for viewing in-memory database)
spring.h2.console.enabled=true
spring.h2.console.path=/h2-console
spring.h2.console.settings.web-allow-others=true
@@@@

---

### Unit Test Cases

$$$$src
$$$$src/test
$$$$src/test/java
$$$$src/test/java/com
$$$$src/test/java/com/example
$$$$src/test/java/com/example/demo
$$$$src/test/java/com/example/demo/service
&&&&ProductServiceTest.java
@@@@
package com.example.demo.service;

import com.example.demo.dto.ProductRequest;
import com.example.demo.dto.ProductResponse;
import com.example.demo.exception.ResourceNotFoundException;
import com.example.demo.model.Product;
import com.example.demo.repository.ProductRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Arrays;
import java.util.List;
import java.util.Optional;

import static org.assertj.core.api.Assertions.assertThat;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

/**
 * Unit tests for the ProductService.
 * Uses Mockito to mock the ProductRepository.
 *
 * @ExtendWith(MockitoExtension.class): Integrates Mockito with JUnit 5.
 */
@ExtendWith(MockitoExtension.class)
class ProductServiceTest {

    @Mock // Creates a mock instance of ProductRepository
    private ProductRepository productRepository;

    @InjectMocks // Injects the mock ProductRepository into ProductService
    private ProductService productService;

    private Product product1;
    private Product product2;
    private ProductRequest productRequest;

    @BeforeEach
    void setUp() {
        product1 = new Product(1L, "Laptop", "High performance laptop", 1200.00);
        product2 = new Product(2L, "Mouse", "Wireless mouse", 25.00);
        productRequest = new ProductRequest("Keyboard", "Mechanical keyboard", 75.00);
    }

    @DisplayName("Test getAllProducts - success")
    @Test
    void whenGetAllProducts_thenReturnProductList() {
        // Given
        when(productRepository.findAll()).thenReturn(Arrays.asList(product1, product2));

        // When
        List<ProductResponse> products = productService.getAllProducts();

        // Then
        assertThat(products).isNotNull();
        assertThat(products.size()).isEqualTo(2);
        assertThat(products.get(0).getName()).isEqualTo("Laptop");
        assertThat(products.get(1).getName()).isEqualTo("Mouse");
        verify(productRepository, times(1)).findAll(); // Verify findAll was called once
    }

    @DisplayName("Test getProductById - success")
    @Test
    void whenGetProductById_thenReturnProductResponse() {
        // Given
        when(productRepository.findById(1L)).thenReturn(Optional.of(product1));

        // When
        ProductResponse foundProduct = productService.getProductById(1L);

        // Then
        assertThat(foundProduct).isNotNull();
        assertThat(foundProduct.getId()).isEqualTo(1L);
        assertThat(foundProduct.getName()).isEqualTo("Laptop");
        verify(productRepository, times(1)).findById(1L);
    }

    @DisplayName("Test getProductById - not found")
    @Test
    void whenGetProductById_thenThrowResourceNotFoundException() {
        // Given
        when(productRepository.findById(99L)).thenReturn(Optional.empty());

        // When & Then
        ResourceNotFoundException exception = assertThrows(ResourceNotFoundException.class, () ->
                productService.getProductById(99L));
        assertThat(exception.getMessage()).isEqualTo("Product not found with id: 99");
        verify(productRepository, times(1)).findById(99L);
    }

    @DisplayName("Test createProduct - success")
    @Test
    void whenCreateProduct_thenReturnNewProductResponse() {
        // Given
        Product newProduct = new Product(null, "Keyboard", "Mechanical keyboard", 75.00);
        Product savedProduct = new Product(3L, "Keyboard", "Mechanical keyboard", 75.00);
        when(productRepository.save(any(Product.class))).thenReturn(savedProduct);

        // When
        ProductResponse createdProduct = productService.createProduct(productRequest);

        // Then
        assertThat(createdProduct).isNotNull();
        assertThat(createdProduct.getId()).isEqualTo(3L);
        assertThat(createdProduct.getName()).isEqualTo("Keyboard");
        verify(productRepository, times(1)).save(any(Product.class));
    }

    @DisplayName("Test updateProduct - success")
    @Test
    void whenUpdateProduct_thenReturnUpdatedProductResponse() {
        // Given
        ProductRequest updateRequest = new ProductRequest("Updated Laptop", "Improved model", 1300.00);
        Product updatedProductEntity = new Product(1L, "Updated Laptop", "Improved model", 1300.00);

        when(productRepository.findById(1L)).thenReturn(Optional.of(product1));
        when(productRepository.save(any(Product.class))).thenReturn(updatedProductEntity);

        // When
        ProductResponse updatedResponse = productService.updateProduct(1L, updateRequest);

        // Then
        assertThat(updatedResponse).isNotNull();
        assertThat(updatedResponse.getId()).isEqualTo(1L);
        assertThat(updatedResponse.getName()).isEqualTo("Updated Laptop");
        assertThat(updatedResponse.getPrice()).isEqualTo(1300.00);
        verify(productRepository, times(1)).findById(1L);
        verify(productRepository, times(1)).save(any(Product.class));
    }

    @DisplayName("Test updateProduct - not found")
    @Test
    void whenUpdateProduct_thenThrowResourceNotFoundException() {
        // Given
        ProductRequest updateRequest = new ProductRequest("NonExistent", "Desc", 100.00);
        when(productRepository.findById(99L)).thenReturn(Optional.empty());

        // When & Then
        ResourceNotFoundException exception = assertThrows(ResourceNotFoundException.class, () ->
                productService.updateProduct(99L, updateRequest));
        assertThat(exception.getMessage()).isEqualTo("Product not found with id: 99");
        verify(productRepository, times(1)).findById(99L);
        verify(productRepository, never()).save(any(Product.class)); // save should not be called
    }

    @DisplayName("Test deleteProduct - success")
    @Test
    void whenDeleteProduct_thenDoNothing() {
        // Given
        when(productRepository.existsById(1L)).thenReturn(true);
        doNothing().when(productRepository).deleteById(1L);

        // When
        productService.deleteProduct(1L);

        // Then
        verify(productRepository, times(1)).existsById(1L);
        verify(productRepository, times(1)).deleteById(1L);
    }

    @DisplayName("Test deleteProduct - not found")
    @Test
    void whenDeleteProduct_thenThrowResourceNotFoundException() {
        // Given
        when(productRepository.existsById(99L)).thenReturn(false);

        // When & Then
        ResourceNotFoundException exception = assertThrows(ResourceNotFoundException.class, () ->
                productService.deleteProduct(99L));
        assertThat(exception.getMessage()).isEqualTo("Product not found with id: 99");
        verify(productRepository, times(1)).existsById(99L);
        verify(productRepository, never()).deleteById(anyLong()); // deleteById should not be called
    }
}
@@@@

$$$$src/test/java/com/example/demo/controller
&&&&ProductControllerTest.java
@@@@
package com.example.demo.controller;

import com.example.demo.dto.ProductRequest;
import com.example.demo.dto.ProductResponse;
import com.example.demo.exception.ResourceNotFoundException;
import com.example.demo.service.ProductService;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;
import org.springframework.boot.test.mock.mockito.MockBean;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;

import java.util.Arrays;
import java.util.List;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyLong;
import static org.mockito.Mockito.*;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.*;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;

/**
 * Unit tests for the ProductController.
 *
 * @WebMvcTest: Focuses on Spring MVC components. It auto-configures Spring MVC
 *              infrastructure and scans for @Controller, @ControllerAdvice, @JsonComponent,
 *              Filter, and WebMvcConfigurer beans.
 *              It doesn't load the full application context.
 * @MockBean: Used to add mock objects to the Spring application context.
 *            If a bean of the same type already exists, it will be replaced.
 */
@WebMvcTest(ProductController.class)
class ProductControllerTest {

    @Autowired
    private MockMvc mockMvc; // Used to simulate HTTP requests

    @Autowired
    private ObjectMapper objectMapper; // Used to convert objects to JSON strings

    @MockBean
    private ProductService productService; // Mock the service layer dependency

    @DisplayName("Test GET /api/products - success")
    @Test
    void whenGetAllProducts_thenReturnListOfProductResponses() throws Exception {
        // Given
        List<ProductResponse> productResponses = Arrays.asList(
                new ProductResponse(1L, "Laptop", "High performance laptop", 1200.00),
                new ProductResponse(2L, "Mouse", "Wireless mouse", 25.00)
        );
        when(productService.getAllProducts()).thenReturn(productResponses);

        // When & Then
        mockMvc.perform(get("/api/products")
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.length()").value(2))
                .andExpect(jsonPath("$[0].name").value("Laptop"))
                .andExpect(jsonPath("$[1].name").value("Mouse"));

        verify(productService, times(1)).getAllProducts();
    }

    @DisplayName("Test GET /api/products/{id} - success")
    @Test
    void whenGetProductById_thenReturnProductResponse() throws Exception {
        // Given
        ProductResponse productResponse = new ProductResponse(1L, "Laptop", "High performance laptop", 1200.00);
        when(productService.getProductById(1L)).thenReturn(productResponse);

        // When & Then
        mockMvc.perform(get("/api/products/{id}", 1L)
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.id").value(1L))
                .andExpect(jsonPath("$.name").value("Laptop"));

        verify(productService, times(1)).getProductById(1L);
    }

    @DisplayName("Test GET /api/products/{id} - not found")
    @Test
    void whenGetProductById_thenReturnsNotFound() throws Exception {
        // Given
        when(productService.getProductById(99L)).thenThrow(new ResourceNotFoundException("Product not found with id: 99"));

        // When & Then
        mockMvc.perform(get("/api/products/{id}", 99L)
                        .contentType(MediaType.APPLICATION_JSON))
                .andExpect(status().isNotFound())
                .andExpect(jsonPath("$.message").value("Product not found with id: 99"))
                .andExpect(jsonPath("$.errorCode").value("NOT_FOUND"));

        verify(productService, times(1)).getProductById(99L);
    }

    @DisplayName("Test POST /api/products - success")
    @Test
    void whenCreateProduct_thenReturnCreatedProductResponse() throws Exception {
        // Given
        ProductRequest request = new ProductRequest("Keyboard", "Mechanical keyboard", 75.00);
        ProductResponse response = new ProductResponse(3L, "Keyboard", "Mechanical keyboard", 75.00);
        when(productService.createProduct(any(ProductRequest.class))).thenReturn(response);

        // When & Then
        mockMvc.perform(post("/api/products")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isCreated())
                .andExpect(jsonPath("$.id").value(3L))
                .andExpect(jsonPath("$.name").value("Keyboard"));

        verify(productService, times(1)).createProduct(any(ProductRequest.class));
    }

    @DisplayName("Test POST /api/products - validation error")
    @Test
    void whenCreateProductWithInvalidData_thenReturnBadRequest() throws Exception {
        // Given
        ProductRequest invalidRequest = new ProductRequest("", "No name", -10.00); // Invalid name and price

        // When & Then
        mockMvc.perform(post("/api/products")
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(invalidRequest)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").value("Validation Failed"))
                .andExpect(jsonPath("$.validationErrors.name").value("Product name is required"))
                .andExpect(jsonPath("$.validationErrors.price").value("Product price must be positive"));

        verify(productService, never()).createProduct(any(ProductRequest.class)); // Service should not be called
    }

    @DisplayName("Test PUT /api/products/{id} - success")
    @Test
    void whenUpdateProduct_thenReturnUpdatedProductResponse() throws Exception {
        // Given
        ProductRequest request = new ProductRequest("Updated Laptop", "Improved model", 1300.00);
        ProductResponse response = new ProductResponse(1L, "Updated Laptop", "Improved model", 1300.00);
        when(productService.updateProduct(anyLong(), any(ProductRequest.class))).thenReturn(response);

        // When & Then
        mockMvc.perform(put("/api/products/{id}", 1L)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isOk())
                .andExpect(jsonPath("$.id").value(1L))
                .andExpect(jsonPath("$.name").value("Updated Laptop"))
                .andExpect(jsonPath("$.price").value(1300.00));

        verify(productService, times(1)).updateProduct(anyLong(), any(ProductRequest.class));
    }

    @DisplayName("Test PUT /api/products/{id} - not found")
    @Test
    void whenUpdateProduct_thenReturnsNotFound() throws Exception {
        // Given
        ProductRequest request = new ProductRequest("NonExistent", "Desc", 100.00);
        when(productService.updateProduct(99L, request)).thenThrow(new ResourceNotFoundException("Product not found with id: 99"));

        // When & Then
        mockMvc.perform(put("/api/products/{id}", 99L)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(request)))
                .andExpect(status().isNotFound())
                .andExpect(jsonPath("$.message").value("Product not found with id: 99"));

        verify(productService, times(1)).updateProduct(99L, request);
    }

    @DisplayName("Test PUT /api/products/{id} - validation error")
    @Test
    void whenUpdateProductWithInvalidData_thenReturnBadRequest() throws Exception {
        // Given
        ProductRequest invalidRequest = new ProductRequest("Valid Name", "Desc", -100.00); // Invalid price

        // When & Then
        mockMvc.perform(put("/api/products/{id}", 1L)
                        .contentType(MediaType.APPLICATION_JSON)
                        .content(objectMapper.writeValueAsString(invalidRequest)))
                .andExpect(status().isBadRequest())
                .andExpect(jsonPath("$.message").value("Validation Failed"))
                .andExpect(jsonPath("$.validationErrors.price").value("Product price must be positive"));

        verify(productService, never()).updateProduct(anyLong(), any(ProductRequest.class));
    }

    @DisplayName("Test DELETE /api/products/{id} - success")
    @Test
    void whenDeleteProduct_thenReturnNoContent() throws Exception {
        // Given
        doNothing().when(productService).deleteProduct(1L);

        // When & Then
        mockMvc.perform(delete("/api/products/{id}", 1L))
                .andExpect(status().isNoContent());

        verify(productService, times(1)).deleteProduct(1L);
    }

    @DisplayName("Test DELETE /api/products/{id} - not found")
    @Test
    void whenDeleteProduct_thenReturnsNotFound() throws Exception {
        // Given
        doThrow(new ResourceNotFoundException("Product not found with id: 99")).when(productService).deleteProduct(99L);

        // When & Then
        mockMvc.perform(delete("/api/products/{id}", 99L))
                .andExpect(status().isNotFound())
                .andExpect(jsonPath("$.message").value("Product not found with id: 99"));

        verify(productService, times(1)).deleteProduct(99L);
    }
}
@@@@