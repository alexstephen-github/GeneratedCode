from django.test import TestCase
from django.urls import reverse
from rest_framework import status
from rest_framework.test import APIClient, APITestCase
from django.contrib.auth.models import User
from .models import Item
from .serializers import ItemSerializer

# --- Model Tests ---
# TestCase is Django's standard base class for tests.
class ItemModelTest(TestCase):
    """Tests for the Item model."""

    def setUp(self):
        """Set up non-modified objects for every test method."""
        self.item = Item.objects.create(name="Test Item", description="This is a test description.")

    def test_item_creation(self):
        """Test that an Item can be created and its attributes are correct."""
        self.assertEqual(self.item.name, "Test Item")
        self.assertEqual(self.item.description, "This is a test description.")
        self.assertIsNotNone(self.item.created_at)
        self.assertIsNotNone(self.item.updated_at)
        self.assertTrue(isinstance(self.item, Item))

    def test_item_str_method(self):
        """Test the __str__ method of the Item model."""
        self.assertEqual(str(self.item), "Test Item")

    def test_item_update(self):
        """Test updating an Item ensures the `updated_at` timestamp changes."""
        old_updated_at = self.item.updated_at
        self.item.name = "Updated Item"
        self.item.save()
        self.assertEqual(self.item.name, "Updated Item")
        # Ensure updated_at has been updated to a newer timestamp.
        self.assertGreater(self.item.updated_at, old_updated_at)

# --- Serializer Tests ---
class ItemSerializerTest(TestCase):
    """Tests for the ItemSerializer."""

    def setUp(self):
        self.item = Item.objects.create(name="Serializer Item", description="Serializer test description")
        self.serializer = ItemSerializer(instance=self.item)

    def test_serializer_contains_expected_fields(self):
        """Verify serializer includes all expected fields."""
        data = self.serializer.data
        self.assertSetEqual(
            set(data.keys()),
            {'id', 'name', 'description', 'created_at', 'updated_at'}
        )

    def test_serializer_data(self):
        """Verify data is correctly serialized from an Item instance."""
        data = self.serializer.data
        self.assertEqual(data['name'], self.item.name)
        self.assertEqual(data['description'], self.item.description)
        self.assertIsNotNone(data['created_at'])
        self.assertIsNotNone(data['updated_at'])

    def test_serializer_create_item(self):
        """Test creating an Item via serializer."""
        data = {'name': 'New Item', 'description': 'New item description'}
        serializer = ItemSerializer(data=data)
        self.assertTrue(serializer.is_valid()) # Check if data is valid for creation.
        item = serializer.save() # Save the new item.
        self.assertEqual(item.name, 'New Item')
        self.assertEqual(item.description, 'New item description')
        self.assertEqual(Item.objects.count(), 2) # Original + New item.

    def test_serializer_update_item(self):
        """Test updating an Item via serializer."""
        data = {'name': 'Updated Serializer Item', 'description': 'Updated description'}
        # `partial=True` allows for partial updates (not all fields required).
        serializer = ItemSerializer(instance=self.item, data=data, partial=True)
        self.assertTrue(serializer.is_valid())
        item = serializer.save()
        self.item.refresh_from_db() # Reload the instance from DB to get updated values.
        self.assertEqual(self.item.name, 'Updated Serializer Item')
        self.assertEqual(self.item.description, 'Updated description')


# --- ViewSet Tests ---
# APITestCase is a specialized TestCase for DRF, providing an APIClient.
class ItemViewSetTest(APITestCase):
    """Tests for the ItemViewSet."""

    def setUp(self):
        self.client = APIClient() # The API client for making requests.
        # Create a test user for authenticated requests.
        self.user = User.objects.create_user(username='testuser', password='testpassword123')
        self.item1 = Item.objects.create(name="Item One", description="Description One")
        self.item2 = Item.objects.create(name="Item Two", description="Description Two")

        # Use `reverse` to get URLs from name patterns, which is more robust.
        # 'item-list' and 'item-detail' are generated by DefaultRouter based on `basename='item'`.
        self.list_url = reverse('item-list')
        self.detail_url = reverse('item-detail', args=[self.item1.id])

        # Log in the user to simulate an authenticated request.
        self.client.login(username='testuser', password='testpassword123')

    def test_list_items(self):
        """Ensure we can list all items, respecting pagination and ordering."""
        response = self.client.get(self.list_url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        # Assuming PAGE_SIZE=10, so both items fit.
        self.assertEqual(len(response.data['results']), 2)

        # Check ordering: `Item.Meta.ordering = ['-created_at']` means newest first.
        # item2 was created after item1, so it should be first in the list.
        self.assertEqual(response.data['results'][0]['name'], self.item2.name)
        self.assertEqual(response.data['results'][1]['name'], self.item1.name)


    def test_create_item(self):
        """Ensure we can create a new item with authenticated request."""
        data = {'name': 'New API Item', 'description': 'New item from API'}
        response = self.client.post(self.list_url, data, format='json')
        self.assertEqual(response.status_code, status.HTTP_201_CREATED) # 201 Created on success.
        self.assertEqual(Item.objects.count(), 3) # Total items in DB.
        self.assertEqual(Item.objects.get(id=response.data['id']).name, 'New API Item')

    def test_retrieve_item(self):
        """Ensure we can retrieve a single item with authenticated request."""
        response = self.client.get(self.detail_url)
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.assertEqual(response.data['name'], self.item1.name)

    def test_update_item(self):
        """Ensure we can update an existing item (full update - PUT) with authenticated request."""
        data = {'name': 'Updated API Item', 'description': 'Updated description from API'}
        response = self.client.put(self.detail_url, data, format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.item1.refresh_from_db() # Get the latest data from the database.
        self.assertEqual(self.item1.name, 'Updated API Item')
        self.assertEqual(self.item1.description, 'Updated description from API')

    def test_partial_update_item(self):
        """Ensure we can partially update an existing item (PATCH) with authenticated request."""
        data = {'name': 'Partially Updated'} # Only updating one field.
        response = self.client.patch(self.detail_url, data, format='json')
        self.assertEqual(response.status_code, status.HTTP_200_OK)
        self.item1.refresh_from_db()
        self.assertEqual(self.item1.name, 'Partially Updated')
        self.assertEqual(self.item1.description, "Description One") # Other fields should remain unchanged.

    def test_delete_item(self):
        """Ensure we can delete an item with authenticated request."""
        response = self.client.delete(self.detail_url)
        self.assertEqual(response.status_code, status.HTTP_204_NO_CONTENT) # 204 No Content for successful deletion.
        self.assertEqual(Item.objects.count(), 1) # Only item2 should remain.
        self.assertFalse(Item.objects.filter(id=self.item1.id).exists()) # Verify item1 is gone.

    def test_unauthenticated_access_denied_for_write_actions(self):
        """Ensure unauthenticated users cannot perform write operations (POST, PUT, PATCH, DELETE)."""
        self.client.logout() # Log out the test user.
        data = {'name': 'Unauthorized Item', 'description': 'Attempt to create'}

        # Attempt to Create (POST)
        response = self.client.post(self.list_url, data, format='json')
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED) # Should be 401 Unauthorized.

        # Attempt to Update (PUT)
        response = self.client.put(self.detail_url, data, format='json')
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)

        # Attempt to Partially Update (PATCH)
        response = self.client.patch(self.detail_url, data, format='json')
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)

        # Attempt to Delete (DELETE)
        response = self.client.delete(self.detail_url)
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)

    def test_unauthenticated_access_denied_for_read_actions(self):
        """
        Ensure unauthenticated users cannot perform read operations (GET)
        when `permission_classes = [IsAuthenticated]`.
        If `permission_classes` were `[IsAuthenticatedOrReadOnly]`, these would return 200 OK.
        """
        self.client.logout() # Log out the test user.

        # Attempt to List (GET)
        response = self.client.get(self.list_url)
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)

        # Attempt to Retrieve (GET specific item)
        response = self.client.get(self.detail_url)
        self.assertEqual(response.status_code, status.HTTP_401_UNAUTHORIZED)
